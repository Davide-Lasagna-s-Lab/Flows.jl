<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Full API · Flows.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Flows.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../quickstart/">Quick Start</a></li><li><a class="toctext" href="../monitors/">Monitors</a></li><li><a class="toctext" href="../available-methods/">Available methods</a></li><li><a class="toctext" href="../coupled/">Coupled systems</a></li><li><a class="toctext" href="../quadrature/">Quadrature equations</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../advanced/">Advanced features</a></li><li class="current"><a class="toctext" href>Full API</a><ul class="internal"><li><a class="toctext" href="#Flow-operator-API-1">Flow operator API</a></li><li><a class="toctext" href="#Monitor-API-1">Monitor API</a></li><li><a class="toctext" href="#Coupled-API-1">Coupled API</a></li><li><a class="toctext" href="#Storage-API-1">Storage API</a></li><li><a class="toctext" href="#Integration-methods-API-1">Integration methods API</a></li><li><a class="toctext" href="#Time-Stepping-API-1">Time Stepping API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Full API</a></li></ul><a class="edit-page" href="https://github.com/gasagna/Flows.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Full API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Full-public-API-1" href="#Full-public-API-1">Full public API</a></h1><h2><a class="nav-anchor" id="Flow-operator-API-1" href="#Flow-operator-API-1">Flow operator API</a></h2><p>The basic building block of this package is the <a href="#Flows.Flow"><code>Flows.Flow</code></a> object, a discrete approximation of the flow of a dynamical system. Here is a list of possible constructors.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.flow" href="#Flows.flow"><code>Flows.flow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">flow(g, m::AbstractMethod, ts::AbstractTimeStepping)</code></pre><p>Construct an object of type <code>Flow</code>, representing the numerical dicretisation of the time-forward flow operator associated to the vector field <code>g</code>, using the integration method <code>m</code>, with time stepping provided by <code>ts</code>. This method should be used with an explicit integration method.</p></div></div><div><div><pre><code class="language-none">flow(g, A, m::AbstractMethod, ts::AbstractTimeStepping)</code></pre><p>Construct a flow operator associated to the vector field defined by a linear component <code>A</code> and a nonlinear part <code>g</code>. An implicit-explicit integration  method <code>m</code> should be provided. </p></div></div><div><div><pre><code class="language-none">flow(g::Coupled{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}</code></pre><p>Construct a flow operator associated to the composite vector field <code>g</code>, using a default call dependency structure, i.e. where the elements of <code>g</code> satisfy the calling interface:</p><pre><code class="language-none">g[1](t, u[1], dudt[1])
g[2](t, u[1], dudt[1], u[2], dudt[2]) ...
g[N](t, u[1], dudt[1], u[N], dudt[N])</code></pre><p>See <a href="@ref">Flows.jl Call Dependencies</a> for more details on how to specify custom call dependencies. This method should be used with an explicit integrator.</p></div></div><div><div><pre><code class="language-none">flow(g::Coupled{N}, spec::CallDependency{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}</code></pre><p>Similar to the method without <code>spec</code>, but specifying a custom call dependency structure.</p></div></div><div><div><pre><code class="language-none">flow(g::Coupled{N}, A::Coupled{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}</code></pre><p>Similar to previous methods, but also provide the linear part of the dynamical system. This method should be used with an implicit-explicit integrator.</p></div></div><div><div><pre><code class="language-none">flow(g::Coupled{N}, A::Coupled{N}, spec::CallDependency{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}</code></pre><p>Similar to previous methods, but provide a custom call dependency structure. This method should be used with an implicit-explicit integrator.</p></div></div></section><p>Objects of type <code>Flow</code> satisfy a callable interface, with additional arguments possible.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.Flow" href="#Flows.Flow"><code>Flows.Flow</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">(I::Flow)(x, span::NTuple{2, Real})</code></pre><p>Map <code>x</code> at time <code>span[1]</code> to the later time <code>span[2]</code>. </p><p>The object <code>x</code> is modified in place. The argument <code>x</code> shoule be of a type  compatible to that used to create the integration method object for the <code>Flow</code> object <code>I</code>, since the integration method contains preallocated elements used  to perform the integration step.</p></div></div><div><div><pre><code class="language-none">(I::Flow)(x, span::NTuple{2, Real}, m::AbstractMonitor)</code></pre><p>Map <code>x</code> at time <code>span[1]</code> to the later time <code>span[2]</code>, filling the monitor obejct <code>m</code> along the way. See <a href="@ref"><code>Flow.jl Monitor objects</code></a> for more details on how to define and use <code>Monitor</code> objects.</p></div></div><div><div><pre><code class="language-none">(I::Flow)(x, span::NTuple{2, Real}, c::AbstractStageCache)</code></pre><p>Map <code>x</code> at time <code>span[1]</code> to the later time <code>span[2]</code>, filling the stage cache obejct <code>c</code> along the way. See <a href="@ref"><code>Flow.jl Stage Caches</code></a> for more details on how to define and use <code>AbstractStageCache</code> objects.</p></div></div><div><div><pre><code class="language-none">(I::Flow)(x, span::NTuple{2, Real}, s::AbstractStorage)</code></pre><p>Map <code>x</code> at time <code>span[1]</code> to the later time <code>span[2]</code>, filling the storage  object <code>s</code> along the way. This method is used primarily to fill a storage  object with the results of a nonlinear simulation, where the storage <code>s</code> can be subsequently used for the linearised systems. See <a href="@ref"><code>Flow.jl Storages</code></a>  for more details on how to define and use <code>AbstractStorage</code> objects.</p></div></div><div><div><pre><code class="language-none">(I::Flow{TimeStepFromCache})(x, c::AbstractStageCache, m::Union{Nothing, &lt;:AbstractMonitor}=nothing)</code></pre><p>Map <code>x</code> forward/backward over a time span defined by the stage cache object <code>c</code>,  filling the monitor object <code>m</code> along the way. This method is primarily used to  integrate linearised equations forward/backward, so that the nonlinear and  linearised methods are discretely consistent. See <a href="@ref"><code>Flow.jl Stage Caches</code></a>  for more details on how to define and use <code>AbstractStorage</code> objects.</p></div></div><div><div><pre><code class="language-none">(I::Flow{TimeStepFromStorage})(x, s::AbstractStorage, span::NTuple{2, Real}, m::Union{Nothing, &lt;:AbstractMonitor}=nothing)</code></pre><p>Map <code>x</code> forward/backward over a time span <code>(span[1], span[2])</code> using the nonlinear trajectory stored in <code>s</code> to drive linearised equations. An additional <code>Monitor</code> object <code>m</code> can be filled along the way. The monitor object is fed with elements that are  similar to <code>x</code>. This method can be used to integrate forward or  adjoint equations in a way that is not discretely consistent.</p></div></div></section><h2><a class="nav-anchor" id="Monitor-API-1" href="#Monitor-API-1">Monitor API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.Monitor" href="#Flows.Monitor"><code>Flows.Monitor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Monitor(x, f::Base.Callable=identity, store::S=RAMStorage(f(x)); oneevery::Int=1, savebetween::Tuple{Real, Real}=(-Inf, Inf), sizehint::Int=0)</code></pre><p>Construct a <code>Monitor</code> object to record one observable quantity along a trajectory. </p><p>The argument <code>x</code> is an object of the same type used to represent the system&#39;s state,  while <code>f</code> is a callable object or function that calculates the observable from the state.  In other words, the quantity <code>f(x)</code> is monitored along a trajectory, and stored in  <code>store</code>, which defaults to a <a href="#Flows.RAMStorage"><code>RAMStorage</code></a> object. One sample every <code>onevery</code>  samples is stored.</p><p>If required, only samples at times falling in the range specified by <code>savebetween</code> are  stored. Specifying the number of samples stored with the <code>sizehint</code> keyword argument may increase performance.</p><p>A <code>Monitor</code> object can then be passed as an additional argument to a <a href="#Flows.Flow"><code>Flows.Flow</code></a> object.</p><p>See also <a href="#Flows.reset!"><code>reset!</code></a>, <a href="#Flows.times"><code>times</code></a> and <a href="#Flows.samples"><code>samples</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.reset!" href="#Flows.reset!"><code>Flows.reset!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reset!(mon::Monitor, sizehint::Int=0)</code></pre><p>Reset the internal storage of a <a href="#Flows.Monitor"><code>Monitor</code></a> object <code>mon</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.times" href="#Flows.times"><code>Flows.times</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">times(mon::Monitor)</code></pre><p>Return the times at which samples of the observable have been stored. This is most  typically after each time step, in addition to the initial condition. The type of the  returned object depend on the internal storage. For <a href="#Flows.RAMStorage"><code>RAMStorage</code></a> storages, this is a standard <code>Vector</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.samples" href="#Flows.samples"><code>Flows.samples</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">samples(mon::Monitor)</code></pre><p>Return samples of the observable that have been stored during a trajectory. This is most  typically after each time step, in addition to the initial condition. The type of the  returned object depend on the internal storage. For <a href="#Flows.RAMStorage"><code>RAMStorage</code></a> storages, this is a standard <code>Vector</code>.</p></div></div></section><h2><a class="nav-anchor" id="Coupled-API-1" href="#Coupled-API-1">Coupled API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.Coupled" href="#Flows.Coupled"><code>Flows.Coupled</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Coupled{N, ARGS&lt;:NTuple{N, Any}} &lt;: AbstractVector{Any}</code></pre><p>Couple together <code>N</code> objects and store them internally in a Julia <code>ntuple</code> of size <code>N</code>.</p><p>Coupled<code>objects are immutable, but their elements must be mutable, allowing the  content to be modified. The individual elements of a</code>Coupled<code>object can be  accessed using the standard indexing notation, but the elements cannot be changed, i.e. there is no</code>Base.setindex!<code>defined for</code>Coupled` objects.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.couple" href="#Flows.couple"><code>Flows.couple</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">couple(args...)</code></pre><p>Create a <code>Coupled</code> object from the sequence of arguments <code>args</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.couplecopy" href="#Flows.couplecopy"><code>Flows.couplecopy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">couplecopy(N::Int, x)</code></pre><p>Couple <code>N</code> copies of <code>x</code> together, created using <code>Base.deepcopy</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Base.getindex(x::Coupled, i::Int)</code></pre><p>Return the <code>i</code>-th element of a <code>Coupled</code> object. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.similar" href="#Base.similar"><code>Base.similar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Base.similar(x::Coupled)</code></pre><p>Call <code>Base.similar</code> on the elements of <code>x</code> and couple them together in a new object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Base.size(::Coupled{N}) where {N}</code></pre><p>Return <code>(N, )</code>, the size of a <code>Coupled{N}</code> object, coupling <code>N</code> elements together.</p></div></div></section><h2><a class="nav-anchor" id="Storage-API-1" href="#Storage-API-1">Storage API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.RAMStorage" href="#Flows.RAMStorage"><code>Flows.RAMStorage</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">empty</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.period" href="#Flows.period"><code>Flows.period</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">period(rs::RAMStorage)</code></pre><p>Return the period of the data, or <code>0</code> if the data in non periodic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.isperiodic" href="#Flows.isperiodic"><code>Flows.isperiodic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isperiodic(rs::RAMStorage)</code></pre><p>Return true if the data stored in <code>rs</code> represent a periodic signal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.timespan" href="#Flows.timespan"><code>Flows.timespan</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">timespan(rs::RAMStorage)</code></pre><p>Return a 2-tuple with the first and last times stored.</p></div></div></section><h2><a class="nav-anchor" id="Integration-methods-API-1" href="#Integration-methods-API-1">Integration methods API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.RK4" href="#Flows.RK4"><code>Flows.RK4</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RK4(x::X, mode::AbstractMode=NormalMode())</code></pre><p>Constructs a <code>RK4</code> integration scheme object for integration with mode <code>mode</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.CNRK2" href="#Flows.CNRK2"><code>Flows.CNRK2</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CNRK2(x::X, mode::AbstractMode=NormalMode())</code></pre><p>Constructs a <code>CNRK2</code> integration scheme object for integration with mode <code>mode</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.CB3R2R2" href="#Flows.CB3R2R2"><code>Flows.CB3R2R2</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CB3R2R2(x::X, mode::AbstractMode=NormalMode())</code></pre><p>Constructs a <code>CB3R2R2</code> integration scheme object for integration with mode <code>mode</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.CB3R2R3c" href="#Flows.CB3R2R3c"><code>Flows.CB3R2R3c</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CB3R2R3c(x::X, mode::AbstractMode=NormalMode())</code></pre><p>Constructs a <code>CB3R2R3c</code> integration scheme object for integration with mode <code>mode</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.CB3R2R3e" href="#Flows.CB3R2R3e"><code>Flows.CB3R2R3e</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CB3R2R3e(x::X, mode::AbstractMode=NormalMode())</code></pre><p>Constructs a <code>CB3R2R3e</code> integration scheme object for integration with mode <code>mode</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.CB4R3R4" href="#Flows.CB4R3R4"><code>Flows.CB4R3R4</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CB4R3R4(x::X, mode::AbstractMode=NormalMode())</code></pre><p>Constructs a <code>CB4R3R4</code> integration scheme object for integration with mode <code>mode</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.ImcA!" href="#Flows.ImcA!"><code>Flows.ImcA!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ImcA!(A, c::Real, y, z)</code></pre><p>Return <code>z</code> that solves the linear problem <code>(I - c*A)*z = y</code>, where <code>c</code> is a scalar,  <code>A</code> a linear operator and <code>I</code> is the identity. </p><p>To use the IMEX schemes in this package, user should add methods to this function for  their custom types, using an efficient implementation. A default implementation when  <code>A</code> is of type <code>LinearAlgebra.Diagonal</code> and <code>y</code> and <code>z</code> is provided by this package.</p><p><strong>Notes</strong></p><p>The name of this function should be read &quot;I-minus-see-A&quot;.</p></div></div></section><h2><a class="nav-anchor" id="Time-Stepping-API-1" href="#Time-Stepping-API-1">Time Stepping API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.TimeStepConstant" href="#Flows.TimeStepConstant"><code>Flows.TimeStepConstant</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TimeStepConstant(Δt::Real)</code></pre><p>Specify that integration should be performed with constant time step <code>Δt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.TimeStepFromStorage" href="#Flows.TimeStepFromStorage"><code>Flows.TimeStepFromStorage</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TimeStepFromStorage(Δt::Real)</code></pre><p>Specify that integration should be performed with constant time step <code>Δt</code>, and  that an <a href="@ref"><code>AbstractStorage</code></a> will be required.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Flows.AbstractTimeStepFromHook" href="#Flows.AbstractTimeStepFromHook"><code>Flows.AbstractTimeStepFromHook</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractTimeStepFromHook</code></pre><p>Abstract type for time stepping schemes where the time step is determined at runtime.</p><p>See <a href="@ref"><code>Flows.jl Adaptive time stepping</code></a></p></div></div></section><footer><hr/><a class="previous" href="../advanced/"><span class="direction">Previous</span><span class="title">Advanced features</span></a></footer></article></body></html>
