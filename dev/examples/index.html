<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Flows.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Flows.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../quickstart/">Quick Start</a></li><li><a class="toctext" href="../monitors/">Monitors</a></li><li><a class="toctext" href="../coupled/">Coupled systems</a></li><li><a class="toctext" href="../quadrature/">Quadrature equations</a></li><li><a class="toctext" href="../storage/">Solution storages</a></li><li><a class="toctext" href="../advanced/">Advanced features</a></li><li class="current"><a class="toctext" href>Examples</a><ul class="internal"><li><a class="toctext" href="#Adjoint-Sensitivity-1">Adjoint Sensitivity</a></li></ul></li><li><a class="toctext" href="../available-methods/">Available methods</a></li><li><a class="toctext" href="../api/">Full API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Examples</a></li></ul><a class="edit-page" href="https://github.com/gasagna/Flows.jl/blob/master/docs/src/examples.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Examples</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h1><h2><a class="nav-anchor" id="Adjoint-Sensitivity-1" href="#Adjoint-Sensitivity-1">Adjoint Sensitivity</a></h2><p>Variational techniques and adjoint methods can sometimes feel quite difficult to the novice, since sophisticated mathematical concepts (function spaces, functionals, etc) are often introduced at an early stage. The use of such advanced concepts, however, provides a robust basis and can often clarify the meaning and value of adjoint equations <a href="#footnote-1">[1]</a>.</p><h3><a class="nav-anchor" id="Fundamentals-1" href="#Fundamentals-1">Fundamentals</a></h3><p>To show how adjoint sensitivity methods can be used in this package we will consider an optimal control problem on a toy model, given by the initial value problem</p><div>\[\label{eq}\tag{1}
\left\{
\begin{array}{rl}
\dot{x}(t) &amp;= x(t)^2 + u(t),\quad t \in [0, T]\\
x(0) &amp;= x_0
\end{array}
\right.\]</div><p>where both the solution <span>$x(t)$</span> and control <span>$u(t)$</span> are assumed to be elements of the function space <span>$\mathcal{S}$</span>, the space of square-integrable continuous functions mapping the interval <span>$[0, T]$</span> to <span>$\mathbb{R}$</span>. We endow this space with the inner product</p><div>\[\langle v(t), w(t)\rangle = \int_0^T v(t)w(t)\mathrm{d}t.\]</div><p>Now consider the objective functional</p><div>\[\hat{\mathcal{J}}[x(t), u(t)] = \int_0^T sin(x(t)) \mathrm{d}t,\]</div><p>mapping two elements of <span>$\mathcal{S}$</span> to <span>$\mathbb{R}$</span>. Because <span>$x(t)$</span> and <span>$u(t)$</span> are related by the initial value problem <span>$(\ref{eq})$</span>, we consider the reduced functional </p><div>\[\mathcal{J}[u(t)] = \int_0^T sin(x(t)) \mathrm{d}t,\]</div><p>mapping one element of <span>$\mathcal{S}$</span> to <span>$\mathbb{R}$</span>, where <span>$x(t)$</span> is assumed to be the solution of <span>$(\ref{eq})$</span>. The goal is find the gradient of the reduced functional with respect to the control <span>$u(t)$</span>, denoted by </p><div>\[\mathrm{d}\mathcal{J}  / \mathrm{d}u(t).\]</div><p>If gradient information is available, gradient descent can be used to optimise the controls and extremise the objective functional. </p><p>To this end, we proceed by first considering an small, arbitrary perturbation to the controls <span>$v(t) \in \mathcal{S}$</span>, producing a small change in the solution of the initial value problem, denoted by <span>$y(t) \in \mathcal{S}$</span> and obeying the linear problem</p><div>\[\label{eq:linear-eq}\tag{2}
\left\{
\begin{array}{rl}
\dot{y}(t) &amp;= 2x(t)y(t) + v(t)\\
y(0) &amp;= 0
\end{array}
\right.\]</div><p>where <span>$y(t)$</span> is initially set to zero because the initial condition of problem (<span>$\ref{eq}$</span>) is assumed not to change when the controls are varied. This is an optimal control problem: we simply wish to modify the future evolution of a system by appropriately tuning the controls, from the same initial state.</p><p>Now, because of this perturbation <span>$y(t)$</span>, the reduced functional will change by a small amount. Linearising its definition shows that this change can be expressed by a new functional</p><div>\[\mathcal{J}&#39;_{u(t)}[v(t)] = \int_0^T cos(x(t)) y(t) \mathrm{d}t,\]</div><p>This notation should read: if the controls <span>$u(t)$</span> are perturbed by a small amount <span>$v(t)$</span>, the change in the objective functional will be expressed by the integral at the right hand side, where <span>$y(t)$</span> is obtained from the solution of the linearised equations (<span>$\ref{eq:linear-eq}$</span>). In fact, this functional defines the directional derivative, the change of some function along a specified direction. </p><p>To obtain the gradient, let&#39;s introduce a function <span>$q(t) \in \mathcal{S}$</span> and consider the identity</p><div>\[\langle q(t), \dot{y}(t) - 2x(t)y(t) - v(t) \rangle = 0,\]</div><p>where <span>$y(t)$</span> is a solution of the linearised problem <span>$(\ref{eq:linear-eq})$</span>. We can add this term to the linear functional <span>$\mathcal{J}&#39;_{u(t)}[v(t)]$</span> obtaining</p><div>\[\mathcal{J}&#39;_{u(t)}[v(t)] = \int_0^T cos(x(t))y(t) + q(t)[\dot{y}(t) - 2x(t)y(t) - v(t) ] \mathrm{d}t,\]</div><p>without having changed anything. However, integrating by parts the term <span>$q(t)\dot{y}(t)$</span> and collectin products of <span>$y(t)$</span> leads to </p><div>\[\mathcal{J}&#39;_{u(t)}[v(t)] = - \int_0^T q(t)v(t) \mathrm{d}t + \int_0^T y(t)[cos(x(t)) - \dot{q}(t) - 2q(t)x(t)]\mathrm{d}t + [q(T)y(T) - q(0)y(0)]\]</div><p>If we now specify that the adjoint function <span>$q(t)$</span> satisfies the initial value problem</p><div>\[\left\{
\begin{array}{rl}
\dot{q}(t) =&amp; 2x(t)q(t) - cos(x(t))\\
q(T) =&amp; 0
\end{array}
\right.\]</div><p>the second and third term vanish identically, since <span>$y(0)$</span> is zero. The interesting thing about the adjoint problem (a linear problem) is that the initial condition is specified at the final time. This is not an issue per se, it just means that instead of marching the equations forward in time, as we would do to solve <span>$(\ref{eq})$</span>, we will have to proceed backwards. However, we can notice that the adjoint equation depends on the solution <span>$x(t)$</span>, which is obtained by marching the equations forward in time. The practical solution is that we will need to store the entire solution <span>$x(t)$</span> in memory (and possibly interpolate it) to solve the adjoint problem. This is not an issue in this toy problem, but it can be quite onerous for simulations of large-scale systems, e.g. direct simulation of turbulent flows.</p><p>With these steps we obtain an expression for the directional derivative</p><div>\[\tag{3}\label{directional-derivative}
\mathcal{J}&#39;_{u(t)}[v(t)] = \langle - q(t),v(t)\rangle = \int_0^T - q(t)v(t) \mathrm{d}t\]</div><p>that does not contain <span>$y(t)$</span>, only the perturbation to the controls. Now, there is a theorem, called the <a href="https://en.wikipedia.org/wiki/Riesz_representation_theorem">Riesz Representation Theorem</a>, that can help us reading the gradient from this expression. In our setting, the theorem states that any linear functional can be represented as the inner product with an element of <span>$\mathcal{S}$</span>. If <span>$\mathcal{L}$</span> is one of such functionals, there exist an element <span>$v_\mathcal{L}(t)$</span> of <span>$\mathcal{S}$</span> such that</p><div>\[\mathcal{L}[v(t)] = \langle v_\mathcal{L}(t), v(t) \rangle = \int_0 ^T v_\mathcal{L}(t)v(t)\mathrm{d}t\]</div><p>Comparing (<span>$\ref{directional-derivative}$</span>) with the basic definition of the directional derivative shows that the gradient is simply</p><div>\[\tag{4}\label{gradient}
\mathrm{d}\mathcal{J}/\mathrm{d}u(t) = - q(t).\]</div><h3><a class="nav-anchor" id="Hands-on-1" href="#Hands-on-1">Hands on</a></h3><p>We now show how to set up and solve the adjoint problem derived in the previous section using this package <a href="#footnote-2">[2]</a>.  First, we discretise functions in <span>$\mathcal{F}$</span> by introducing a uniform temporal mesh given by <span>$N+1$</span> times <span>$t_i = (i-1) \Delta t$</span>, <span>$i=1, N+1$</span>, with <span>$\Delta t = T/N$</span>. Without loss of generality, let us take <span>$T=1$</span>, so that the mesh is defined by the Julia range</p><pre><code class="language-julia">ti = 0:0.01:1</code></pre><p>An element <span>$u(t)$</span> of <span>$\mathcal{S}$</span> will thus be discretised into a Julia <code>Vector</code> of <span>$N+1$</span> elements, denoted by <code>u</code> with <span>$u(t_i)$</span>=<code>u[i]</code>. </p><p>The first ingredient is that we need code to solve the initial value problem (<span>$\ref{eq}$</span>) for any arbitrary control <span>$u(t)$</span>. This can be achieved by introducing a custom type <code>NonLinearSystem</code> defined as</p><pre><code class="language-julia">struct NonLinearSystem{U}
    _u::U
    function NonLinearSystem(ti::AbstractVector, u::AbstractVector)
        # construct interpolator from t and u
        _u = interp(ti, u)
        return new{typeof(_u)}(_u)
    end
end</code></pre><p>Here, <code>interp</code> is some Julia function (not defined here) that interpolates the function given by the Julia <code>Vector</code>s <code>ti</code> and <code>u</code> at any arbitrary time, e.g. using a linear interpolation scheme. We need this interpolator since the time stepping scheme might call the rigth hand side in <span>$(\ref{eq})$</span> at times in between the available mesh points. Code that evaluates the right hand side is, for instance, </p><pre><code class="language-julia">function (sys::NonLinearSystem)(t, x, dxdt)
    dxdt[1] = x[1]^2 + sys._u(t)
    return nothing
end</code></pre><p>Note how we call the interpolator <code>sys._u</code> at the input time <code>t</code>.</p><p>We now need code to solve the adjoint problem. This can again be achieved by introducing a custom Julia type, <code>AdjointSystem</code>, defined as</p><pre><code class="language-julia">struct AdjointSystem{X}
    _x::X
    function AdjointSystem(ti::AbstractVector, x::AbstractVector)
        # construct interpolator from t and x
        _x = interp(ti, x)
        return new{typeof(_x)}(_x)
    end
end</code></pre><p>where the constructor requires a vector of times <code>ti</code> and a vector of solution points <code>x</code>. These are used in the constructor to build an interpolator <code>_x</code> so that we can have access to the state <span>$x(t)$</span> while marching the adjoint equation backwards.</p><p>The right hand side of the adjoint problem can be coded up in this way:</p><pre><code class="language-julia">function (sys::AdjointSystem)(t, q, dqdt)
    x = sys._x(t)
    dqdt[1] = 2*x*q[1] - cos(x)
    return nothing
end</code></pre><p>where we first interpolate the solution <span>$x(t)$</span> and then evaluate the right hand side.</p><p>So far, we have only seen user code, and not really how to use this package. Hence, we first define the forward problem, by constructing a right hand side (with zero control)</p><pre><code class="language-julia">f = NonLinearSystem(ts, zeros(ti))</code></pre><p>and then defining its associated flow operator </p><pre><code class="language-julia">F = flow(f, RK4(zeros(1)), TimeStepConstant(0.01))</code></pre><p>constructed using a Runge-Kutta integration method. Note how the state is represented by a one element <code>Vector</code>, since state object must be mutable in this package. To obtain the forward solution, we define a monitor extracting the first component</p><pre><code class="language-julia">mon_F = Monitor(zeros(1), x-&gt;x[1])</code></pre><p>and then solve the problem forward from some initial condition <code>x0 = Float64[1.0]</code> by</p><pre><code class="language-julia">F(x0, extrema(ts), mon)</code></pre><p>The <code>Monitor</code> object now contains samples of the state at the end of every time step. We can use these samples to define the adjoint system</p><pre><code class="language-julia">g = AdjointSystem(ts, samples(mon))</code></pre><p>and then the adjoint flow operator</p><pre><code class="language-julia">G = flow(f, RK4(zeros(1), ContinuousMode(), true), TimeStepConstant(0.01))</code></pre><p>Note how</p><ul><li>the <code>RK4</code> is passed extra arguments, <code>true</code> indicating that we have an adjoint problem, to be marched backwards.</li><li>the time step, 0.01, is constant and positive.</li></ul><p>With the adjoint flow operator defined, we can now solve the adjoint problem. We first define a <code>Monitor</code> to observe the adjoint solution, flipping its sign to be compatible with the definition of the gradient <span>$(\ref{gradient})$</span></p><pre><code class="language-julia">mon_G = Monitor(zeros(1), q -&gt; - q[1])</code></pre><p>To obtain the gradient, we march the equations backwards in time from a zero terminal condition</p><pre><code class="language-julia">G(zeros(0), reverse(extrema(ts)), mon_G)</code></pre><p>and get the gradient by <code>samples(mon_G)</code>. </p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>The exposition is meant to be illustrative and mostly addressed to the author&#39;s students having to learn this material to complete their project</p></div><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p>Note that the approach implemented in this package is the diffentiate-then-discretize.</p></div><footer><hr/><a class="previous" href="../advanced/"><span class="direction">Previous</span><span class="title">Advanced features</span></a><a class="next" href="../available-methods/"><span class="direction">Next</span><span class="title">Available methods</span></a></footer></article></body></html>
