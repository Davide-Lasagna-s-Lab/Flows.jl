<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick Start · Flows.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Flows.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Quick Start</a><ul class="internal"><li><a class="toctext" href="#Fundamentals-1">Fundamentals</a></li><li><a class="toctext" href="#User-interface-1">User interface</a></li><li><a class="toctext" href="#Finally-defining-the-flow-operator-1">Finally defining the flow operator</a></li></ul></li><li><a class="toctext" href="../monitors/">Monitors</a></li><li><a class="toctext" href="../available-methods/">Available methods</a></li><li><a class="toctext" href="../coupled/">Coupled systems</a></li><li><a class="toctext" href="../quadrature/">Quadrature equations</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../advanced/">Advanced features</a></li><li><a class="toctext" href="../api/">Full API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Quick Start</a></li></ul><a class="edit-page" href="https://github.com/gasagna/Flows.jl/blob/master/docs/src/quickstart.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Quick Start</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Quick-start-1" href="#Quick-start-1">Quick start</a></h1><h2><a class="nav-anchor" id="Fundamentals-1" href="#Fundamentals-1">Fundamentals</a></h2><p>Thorughout this package we consider dynamical systems defined by an evolution equation of the type</p><div>\[\dot{\mathbf{x}}(t) = \mathcal{L}\mathbf{x}(t) + \mathbf{f}(t, \mathbf{x}(t))\]</div><p>where <span>$t$</span> is time and <span>$\mathbf{x}$</span> is the state, an element of some space <span>$\mathcal{X}$</span>. </p><p>The operator <span>$\mathcal{L}$</span> is linear and time invariant and contains stiff terms that are advanced implictly in time. The function <span>$\mathbf{f}(t, \mathbf{x}(t))$</span> is a nonlinear term that is advanced using an explicit scheme. This notation is purely operational: if the dynamical system does not have any stiff terms and can be advanced using an explicit scheme, all terms can be lumped into the function <span>$\mathbf{f}(t, \mathbf{x}(t))$</span>.</p><p>In many situations in dynamical systems theory, one requires the flow of the vector field <span>$\mathbf{f}$</span>, the nonlinear operator <span>$\mathbf{\Phi}^t : \mathcal{X} \mapsto \mathcal{X}$</span> mapping the state <span>$\mathbf{x}_0$</span> at <span>$t=t_0$</span> to its forward-in-time image <span>$\mathbf{x}(t)$</span>. Mathematically, this operation is</p><div>\[\mathbf{x}(t) = \mathbf{\Phi}^{t-t_0} \mathbf{x}_0.\]</div><p>The structure of this package, and the API it provides, is entirely based on satisfying this flow interface, where a <a href="@ref"><code>Flow</code></a> object is constructed that acts as the time discrete version of <span>$\mathbf{\Phi}$</span>.</p><h2><a class="nav-anchor" id="User-interface-1" href="#User-interface-1">User interface</a></h2><p>To construct a <a href="@ref"><code>Flow</code></a> object, the user needs to write Julia code for the state object <span>$\mathbf{x}$</span> and for the right-hand-side <span>$\mathbf{f}$</span>, in addition to specifing what integration scheme will be used to advance the state in time.</p><h3><a class="nav-anchor" id="Defining-state-objects-1" href="#Defining-state-objects-1">Defining state objects</a></h3><p>The package works transparently on state objects <code>x</code> of arbitrary Julia type, say objects of some user defined Julia type <code>X</code> that might loosely map to their mathematical equivalent <span>$\mathcal{X}$</span> and which may provide some advanced API. </p><p>State objects represented by a standard Julia <code>AbstractArray</code>s (of any dimension) work out-of-the-box. However, the requirement of expressing computations with object of type <code>AbstractArray</code>, or even just <code>Vector</code>, can be quite restrictive in practice and would not leverage the multiple dispatch capabilities of Julia. As an example, consider solving a time dependent partial differential equation over a one-dimensional domain using a Fourier-Galerkin method. The user might wish to define a <code>SpectralField</code> type representing fields, with a custom API for, e.g., computing the derivative field. </p><pre><code class="language-julia">struct SpectralField{T&lt;:AbstractFloat}
    data::Vector{Complex{T}}
end

ddx(u::SpectralField) = # some definitions
</code></pre><p>To work with the package, user types should satisfy these two requirements:</p><ul><li>support dot-broadcasting in in-place algebraic expressions including scalars and objects of the same type. For instance, notation like <code>x .= 3.0.*y .+ 4.0.*z</code> for three elements <code>x</code>, <code>y</code> and <code>z</code> of the user type should be supported.</li></ul><ul><li>provide methods for <code>Base.similar(x)</code> and <code>Base.copy(x)</code>.</li></ul><p>Internally, the package makes extensive use of the dot notation, when updating cache objects during a time step. The restriction prevents having immutable <code>StaticArrays</code> objects as state objects, which would probably lead to faster code on small problems. This is less important for the intended applications of this package, i.e. turbulent flow simulations where the state is generally given by multiple large three-dimensional arrays and having mutable objects is important for performance.</p><h3><a class="nav-anchor" id="Defining-the-right-hand-side-1" href="#Defining-the-right-hand-side-1">Defining the right hand side</a></h3><p>Given a state <code>x</code> as an object of type <code>X</code>, the steps required to specify the right hand side depend on whether an explicit or semi-implicit integration method is used.</p><p>For explicit methods, a dynamical system is specified by a Julia function or some other callable object that has a method with signature</p><pre><code class="language-julia">f(t::Real, x::X, dxdt::X) where {X}</code></pre><p>This function is supposed to operate in place and should modify the content of the third argument <code>dxdt</code> with the time derivative at <code>x</code>, and if needed, time <code>t</code>. Modifying the content of the second argument in the body of this function is undefined behaviour. </p><div class="admonition example"><div class="admonition-title">Example</div><div class="admonition-text"><p>Consider defining a custom type implementing the right-hand-side of the Lorenz equations. A Julia type is defined with one field for the parameter <span>$\rho$</span>:</p><pre><code class="language-julia">struct Lorenz 
    ρ::Float64
    Lorenz(ρ::Real = 28.0) = new(ρ)
end</code></pre><p>Then, the type is made callable by defining the following method:</p><pre><code class="language-julia">function (eq::Lorenz)(t, u, dudt)
    x, y, z = u
    dudt[1] =  10 * (y - x)
    dudt[2] =  eq.ρ *  x - y - x*z
    dudt[3] = -8/3 * z + x*y
    return dudt
end</code></pre><p>Note how this function returns the argument that has been modified. This is not required by the package API, but can be useful in other situations.</p></div></div><p>The semi-implicit methods that are currently implemented assume that the stiff term is linear and given by an time-invariant operator <span>$\mathcal{L}$</span>. To define this term, the user must define a Julia type, say <code>A</code>, with a method for the <code>LinearAlgebra</code> function <code>mul!</code>, with signature</p><pre><code class="language-julia">LinearAlgebra.mul!(out::X, a::A, x::X)</code></pre><p>which computes the action of <code>a</code> on <code>x</code> and stores it in <code>out</code>. Modifying the content of <code>x</code> is undefined behaviour. </p><p>In addition, the type <code>A</code> should have a method for the function <code>Flows.ImcA</code>, provided by this package, with signature</p><pre><code class="language-julia">Flows.ImcA(a::A, c::Real, y::X, z::X)</code></pre><p>to solves the linear system </p><div>\[    (a - c I)z = y\]</div><p>for some right hand side <code>y</code> of type <code>X</code> and a scalar <code>c</code> and stores the result in <code>z</code>, again of type <code>X</code>.</p><h3><a class="nav-anchor" id="Defining-the-integration-scheme-1" href="#Defining-the-integration-scheme-1">Defining the integration scheme</a></h3><p>Performing a time step typically requires temporary objects for intermediate computations, e.g. the internal stages of a Runge-Kutta method. In this package, these temporary objects are pre-allocated by creating an helper object, an instance of one of the concrete subtypes of <code>AbstractMethod</code> provided by the package (see <a href="../available-methods/#Available-integration-schemes-1">Available integration schemes</a>).</p><p>All constructors of such helper objects have the same signature and require a single argument of type <code>X</code>. This argument is used internally in the constructor to to pre-allocate as many similar <code>similar</code> objects as needed for the intermediate computations in the time step. </p><div class="admonition example"><div class="admonition-title">Example</div><div class="admonition-text"><p>Consider using the classical fourth-order Runge-Kutta method to integrate the Lorenz equations defined above. The state vector is implemented using a standard Julia <code>Vector</code> of three elements, and the helper object is constructed by</p><pre><code class="language-julia">method = RK4(zeros(3))</code></pre></div></div><h3><a class="nav-anchor" id="Defining-the-time-stepping-method-1" href="#Defining-the-time-stepping-method-1">Defining the time stepping method</a></h3><p>Once the integration scheme is defined, the user needs to specify a time stepping method. This is essentially a specification of how time steps should be selected to advance the state forward in time. This package provides different methods, but for the purpose of this quick start document, we only document one of the most used, <code>TimeStepConstant</code>. As the name suggested, this method indicates that the time step should be constant and equal to a value specified at construction. </p><p>This is achieved by constructing a <code>TimeStepConstant</code> object as:</p><pre><code class="language-julia">steps = TimeStepConstant(0.1)</code></pre><p>which signals that a constant time step <span>$\Delta t = 0.1$</span> will be used in the integration.</p><h2><a class="nav-anchor" id="Finally-defining-the-flow-operator-1" href="#Finally-defining-the-flow-operator-1">Finally defining the flow operator</a></h2><p>With state, dynamical system, integration method and time stepping defined, we are finally ready to define the flow operator. This is achieved by using the <code>flow</code> function, which constructs a <code>Flow</code> object. It has two methods, with signature</p><pre><code class="language-julia">flow(f::Any, method::AbstractMethod, stepping::AbstractTimeStepping)</code></pre><p>and </p><pre><code class="language-julia">flow(f::Any, L::Any, method::AbstractMethod, stepping::AbstractTimeStepping)</code></pre><p>for problems that are integrated using explicit or semi-implicit methods, respectively.</p><p>A <code>Flow</code> object is callable with the signature </p><pre><code class="language-julia">(::Flow)(x::X, span::Tuple{Real, Real})</code></pre><p>and propagates the state object <code>x</code> from time <code>span[1]</code> to a later time <code>span[2]</code>, returning its first argument. The key observation is that for performance reasons the flow operator operates in place and overwrites its first argument. </p><div class="admonition example"><div class="admonition-title">Example</div><div class="admonition-text"><p>This example demonstrates how to construct a <code>Flow</code> object approximating the flow of the Lorenz equations (defined above) using a classical fourth-order Runge-Kutta scheme with constant time step <span>$\Delta t = 0.1$</span>.</p><p>The <code>Flow</code> object is constructed by</p><pre><code class="language-julia">F = flow(Lorenz(28), RK4(zeros(3)), TimeStepConstant(1e-2))</code></pre><p>A point on the attractor can be then obtained by propagating a random initial conditions by some amount of time ```julia x = F(rand(3), (0, 100))</p></div></div><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../monitors/"><span class="direction">Next</span><span class="title">Monitors</span></a></footer></article></body></html>
