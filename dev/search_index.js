var documenterSearchIndex = {"docs":
[{"location":"time-stepping/#Time-stepping-schemes-1","page":"Time stepping schemes","title":"Time stepping schemes","text":"","category":"section"},{"location":"coupled/#Coupled-dynamical-systems-1","page":"Coupled systems","title":"Coupled dynamical systems","text":"","category":"section"},{"location":"coupled/#Motivation-1","page":"Coupled systems","title":"Motivation","text":"","category":"section"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"In some situations, the state is defined by two or more heterogeneous components, each obeying its own dynamics, but with some components that depend on each other. For instance, consider a problem where the state mathbfz is defined by two components, say mathbfxinmathcalX and mathbfyinmathcalY, as","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"mathbfz = mathbfx mathbfy","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"where now mathbfz in mathcalZ equiv mathcalXtimes mathcalY. Assume the dynamics of mathbfx(t) to be independent from that of mathbfy(t), but that the latter somehow depends on the former. This situation would correspond to the problem","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"left\nbeginarraycc\n  dotmathbfx(t) = mathbff(t mathbfx(t))\n  dotmathbfy(t) = mathbfg(t mathbfx(t) mathbfy(t))\nendarray\nright","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"A possible strategy to solve this problem is to first solve the first differential equation, store its solution, and the use it to solve the second, perhaps using some kind of interpolation if required. Storing a full solution is often not possible or desirable and the two systems must be solved in a coupled manner.","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"example: Example\nA notable example is the solution of the linearised variational equations, governing the evolution of small perturbations to the initial conditions of an initial value problem. If mathbfx(t) denotes the system's state governed by a nonlinear differential equation and mathbfy(t) denotes the perturbation, the two components obey the coupled problemleft\nbeginarrayc\n  dotmathbfx(t) = mathbff(t mathbfx(t))\n  dotmathbfy(t) = mathbff_mathbfx(t mathbfx(t))cdotmathbfy(t)\nendarray\nrightwhere mathbff_mathbfx is the jacobian of mathbff.","category":"page"},{"location":"coupled/#Approach-1","page":"Coupled systems","title":"Approach","text":"","category":"section"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"The fundamental tool provided by this package to address this need is the couple function, accepting two or more arguments and returning a Coupled object. This is a compact representation akin to a Julia Tuple object (internally, it is a shallow wrapper to a tuple) and thus behaves similar to it. For instance","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"julia> z = couple(Int[1, 2, 3], Float64[0, 4])\n2-element Coupled{2,Tuple{Array{Int64,1},Array{Float64,1}}}:\n [1, 2, 3]\n [0.0, 4.0]\n\njulia> z[1] # it is indexable\nInt[1, 2, 3]\n\njulia> length(z) # it has a length\n2","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"One feature of Coupled objects is that they support Julia's dot notation and operations are forwarded down to each of the internal components. For instance, code such as ","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"julia> z1 = couple(Int[1, 2, 3], Float64[0, 4]);\njulia> z2 = couple(Int[2, 4, 5], Float64[1, 2]);\njulia> z1 .= z2 .* 2\n2-element Coupled{2,Tuple{Array{Int64,1},Array{Float64,1}}}:\n [4, 8, 10]\n [2.0, 4.0]","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"works as expected, where arithmetic operations are forwarded to the two components. The utility of this behaviour is that the arithmetic operations arising in the computation of a time step, e.g. during internal stages of a Runge-Kutta method, are forwarded to all components.","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"note: Note\nDespite supporting the dot-broadcasting notation, its usage is provate and should not be relied upon in user code.","category":"page"},{"location":"coupled/#Example-1","page":"Coupled systems","title":"Example","text":"","category":"section"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"Assume that we want to solve the problem ","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"left\nbeginarraycc\n  dotmathbfx(t) = mathbff(t mathbfx(t))\n  dotmathbfy(t) = mathbfg(t mathbfx(t) mathbfy(t))\nendarray\nright","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"where the two components mathbfx(t) in mathbbR^3 and mathbfy(t) in mathbbR^2 are represented by standard Julia Vectors, for simplicity. Assume that two Julia functions f and g have been defined, with signatures","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"f(t, x, dxdt)\ng(t, x, dxdt, y, dydt)","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"Note the definition of the second function, and how it maps to the original problem.","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"Assume that an explicit fourth-order Runge-Kutta method, provided by this package's RK4 type is used to advance the system. Two steps are neeeded. First, we couple together the Julia functions representing the two components by defining","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"h = couple(f, g)","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"Second, we define a composite RK4 method object with ","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"m = RK4(couple(zeros(3), zeros(2)))","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"where we have passed an instance of the type representing the coupled state, obtained by coupling together two temporary Vectors of the right size.","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"The flow operator can then finally be constructed as","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"F = flow(h, m, TimeStepConstant(0.1))","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"where we have declared that we will march the equations forward with time step Δt = 0.1.","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"The flow operator F can now be called on a composite state object. For instance, we define some initial conditions and march the problem in time, with","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"x0 = Float64[0, 1, 0]\ny0 = Float64[2, 3]\n\nF(couple(x0, y0), (0, 1))","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"Because F modifies its first argument in place, the Vectors x0 and y0 are modified by the call to F.","category":"page"},{"location":"advanced/#Advanced-features-1","page":"Advanced features","title":"Advanced features","text":"","category":"section"},{"location":"advanced/#Call-dependencies-1","page":"Advanced features","title":"Call dependencies","text":"","category":"section"},{"location":"advanced/#","page":"Advanced features","title":"Advanced features","text":"When solving several coupled systems, the default settings are such that the signature of the first, second, third and so on functions should be","category":"page"},{"location":"advanced/#","page":"Advanced features","title":"Advanced features","text":"f1(t, x1, dx1dt)\nf2(t, x1, dx1dt, x2, dx2dt)\nf3(t, x1, dx1dt, x2, dx2dt, x3, dx3dt)\nf4(t, x1, dx1dt, x2, dx2dt, x3, dx3dt, x4, dx4dt)","category":"page"},{"location":"advanced/#","page":"Advanced features","title":"Advanced features","text":"This is not always desirable. For instance, assume we need to solve the problem","category":"page"},{"location":"advanced/#","page":"Advanced features","title":"Advanced features","text":"tag1labeleq\nleft\nbeginarraycc\n  dotmathbfx(t)   = mathbff(t mathbfx(t))\n  dotmathbfy_1(t) = mathbfg_1(t mathbfx(t) mathbfy_1(t))\n  dotmathbfy_2(t) = mathbfg_2(t mathbfx(t) mathbfy_2(t))\n  dotmathbfy_3(t) = mathbfg_3(t mathbfx(t) mathbfy_3(t))\nendarray\nright","category":"page"},{"location":"advanced/#","page":"Advanced features","title":"Advanced features","text":"where we might wish to express the structure for the function calls. ","category":"page"},{"location":"advanced/#","page":"Advanced features","title":"Advanced features","text":"This can be achieved in this package by using a CallDependency object. The constructor accepts as many tuples of integers as many equations we need to solve. Each tuple specifies what states are required in the signature. For instance, for the example (refeq) the correct call dependency specification is ","category":"page"},{"location":"advanced/#","page":"Advanced features","title":"Advanced features","text":"deps = CallDependency((1,), (1, 2), (1, 3), (1, 4))","category":"page"},{"location":"advanced/#","page":"Advanced features","title":"Advanced features","text":"Clearly, the signatures of the functions f, g1, g2, and g3 must be consistent with this specification, i.e. should be","category":"page"},{"location":"advanced/#","page":"Advanced features","title":"Advanced features","text":"f(t, x, dxdt)\ng1(t, x, dxdt, y1, dy1dt)\ng2(t, x, dxdt, y2, dy2dt)\ng3(t, x, dxdt, y3, dy3dt)","category":"page"},{"location":"advanced/#","page":"Advanced features","title":"Advanced features","text":"The deps object is then passed as an additional argument to the constructor of the Flows.Flow object. For instance, for an explicit method","category":"page"},{"location":"advanced/#","page":"Advanced features","title":"Advanced features","text":"F = flow(couple(f, g1, g2, g3), deps, otherargs...)","category":"page"},{"location":"quadrature/#Calculating-integrals-1","page":"Quadrature equations","title":"Calculating integrals","text":"","category":"section"},{"location":"quadrature/#Fundamentals-1","page":"Quadrature equations","title":"Fundamentals","text":"","category":"section"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"It is sometimes necessary to calculate the integral of some function g  mathcalX rightarrow mathbbR along a trajectory of the system, i.e. the integral","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"I = int_0^T g(mathbfx(t))mathrmdt","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"where mathbfx(t)inmathcalX is the system's state.","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"This can be achieved by adding a pure quadrature equation, i.e. augmenting the dynamical system with a further equations that gets integrated in time jointly with the main problem. In other words, the coupled system","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"left\nbeginarrayc\n  dotmathbfx(t) = mathbff(t mathbfx(t))\n  dotI(t) = g(mathbfx(t))\nendarray\nright","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"is integrated from 0 to T with initial condition I(0) = 0. It is easy to see that the final condition I(T)  is the numerical approximation of the integral above. This package's implementation of this feature relies on the ability to march coupled systems of equations (see Flows.jl Coupled systems).","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"The usefulness of this approach is that the integral is obtained without doing much, at the end of the integration. In addition, the order of accuracy of the integration methods used to advance the coupled state is the order of accuracy of the estimation of the integral above.","category":"page"},{"location":"quadrature/#Approach-1","page":"Quadrature equations","title":"Approach","text":"","category":"section"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"As an example let us compute the integral of the function ","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"g(mathbfx) = x_1^2","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"for a system with three degrees of freedom arranged in a standard Julia Vector. First we define the quadrature equation ","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"g(t, x, dxdt, I, dIdt) = (dIdt[1] = x[1]^2; return dIdt)","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"Note the structure of the signature, which is characteristic of coupled systems (see Coupled systems).","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"We then define some initial conditions, making sure I[1] is initially set to  zero.","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"x = Float64[1.0, 3.0, 4.0]\nI = Float64[0.0]","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"Note that because the state must be mutable, the extra quadrature variable must be stored in a mutable container, a one element Vector. In fact, one can calculate the integral of as many functions as desired, just define the function g above to fill as many components of dIdt as required.","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"We then define a Flows.Flow operator, by coupling the right hand side of the differential equation (assume it is defined by a julia function f) and the additional quadrature equation","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"F = flow(couple(f, g), RK4(couple(x, I)), TimeStepConstant(0.1))","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"Note how the state and the quadrature variables are coupled toghether and passed to the RK4 constructor. This makes sure that the temporary objects in the Runge-Kutta scheme are consistent with the extra degree of freedom.","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"The flow operator can be now called with","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"F(couple(x, I), (0, 10))","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"where x is advanced forward in time from t=0 to t=10. Upon return I[1] contains an approximation of the integral","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"int_0^10 x_1^2(t)mathrmdt","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"example: Example\nIt is possible to monitor the value of the quadrature variable along a simulation. For instance, let us calculate the cumulative average of the function g(mathbfx(t)), the quantitybarg(tau) = frac1tau int_0^tau g(mathbfx(t))mathrmdtTo do so, simply define a Monitor object that observes the quadrature componentmon = Monitor(couple(x, I), xq->xq[2])After numerical integration, samples of the function barg can be obtained asg_bar = samples(mon)./times(mon)where the first element is undefined.","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"note: Note\nThe quadrature equation can typically be integrated explicitly, even if a semi-implicit scheme is required for the main dynamics. In this case, one can couple the stiff linear part, say f_im, with the nothing value, asF = flow(couple(f_ex, g), couple(f_im, nothing), CNRK2(couple(x, I)), TimeStepConstant(0.1))where CNRK2 is used as an example. The value nothing signals that the quadrature g is advanced in time using on the explicit component of the semi-implicit scheme.","category":"page"},{"location":"api/#Full-public-API-1","page":"Full API","title":"Full public API","text":"","category":"section"},{"location":"api/#Flow-operator-API-1","page":"Full API","title":"Flow operator API","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"The basic building block of this package is the Flows.Flow object, a discrete approximation of the flow of a dynamical system. Here is a list of possible constructors.","category":"page"},{"location":"api/#","page":"Full API","title":"Full API","text":"flow","category":"page"},{"location":"api/#Flows.flow","page":"Full API","title":"Flows.flow","text":"flow(g, m::AbstractMethod, ts::AbstractTimeStepping)\n\nConstruct an object of type Flow, representing the numerical dicretisation of the time-forward flow operator associated to the vector field g, using the integration method m, with time stepping provided by ts. This method should be used with an explicit integration method.\n\n\n\n\n\nflow(g, A, m::AbstractMethod, ts::AbstractTimeStepping)\n\nConstruct a flow operator associated to the vector field defined by a linear component A and a nonlinear part g. An implicit-explicit integration  method m should be provided. \n\n\n\n\n\nflow(g::Coupled{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}\n\nConstruct a flow operator associated to the composite vector field g, using a default call dependency structure, i.e. where the elements of g satisfy the calling interface:\n\ng[1](t, u[1], dudt[1])\ng[2](t, u[1], dudt[1], u[2], dudt[2]) ...\ng[N](t, u[1], dudt[1], u[N], dudt[N])\n\nSee Flows.jl Call Dependencies for more details on how to specify custom call dependencies. This method should be used with an explicit integrator.\n\n\n\n\n\nflow(g::Coupled{N}, spec::CallDependency{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}\n\nSimilar to the method without spec, but specifying a custom call dependency structure.\n\n\n\n\n\nflow(g::Coupled{N}, A::Coupled{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}\n\nSimilar to previous methods, but also provide the linear part of the dynamical system. This method should be used with an implicit-explicit integrator.\n\n\n\n\n\nflow(g::Coupled{N}, A::Coupled{N}, spec::CallDependency{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}\n\nSimilar to previous methods, but provide a custom call dependency structure. This method should be used with an implicit-explicit integrator.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"Full API","title":"Full API","text":"Objects of type Flow satisfy a callable interface, with additional arguments possible.","category":"page"},{"location":"api/#","page":"Full API","title":"Full API","text":"Flows.Flow","category":"page"},{"location":"api/#Flows.Flow","page":"Full API","title":"Flows.Flow","text":"(I::Flow)(x, span::NTuple{2, Real})\n\nMap x at time span[1] to the later time span[2]. \n\nThe object x is modified in place. The argument x shoule be of a type  compatible to that used to create the integration method object for the Flow object I, since the integration method contains preallocated elements used  to perform the integration step.\n\n\n\n\n\n(I::Flow)(x, span::NTuple{2, Real}, m::AbstractMonitor)\n\nMap x at time span[1] to the later time span[2], filling the monitor obejct m along the way. See Flow.jl Monitor objects for more details on how to define and use Monitor objects.\n\n\n\n\n\n(I::Flow)(x, span::NTuple{2, Real}, c::AbstractStageCache)\n\nMap x at time span[1] to the later time span[2], filling the stage cache obejct c along the way. See Flow.jl Stage Caches for more details on how to define and use AbstractStageCache objects.\n\n\n\n\n\n(I::Flow)(x, span::NTuple{2, Real}, s::AbstractStorage)\n\nMap x at time span[1] to the later time span[2], filling the storage  object s along the way. This method is used primarily to fill a storage  object with the results of a nonlinear simulation, where the storage s can be subsequently used for the linearised systems. See Flow.jl Storages  for more details on how to define and use AbstractStorage objects.\n\n\n\n\n\n(I::Flow{TimeStepFromCache})(x, c::AbstractStageCache, m::Union{Nothing, <:AbstractMonitor}=nothing)\n\nMap x forward/backward over a time span defined by the stage cache object c,  filling the monitor object m along the way. This method is primarily used to  integrate linearised equations forward/backward, so that the nonlinear and  linearised methods are discretely consistent. See Flow.jl Stage Caches  for more details on how to define and use AbstractStorage objects.\n\n\n\n\n\n(I::Flow{TimeStepFromStorage})(x, s::AbstractStorage, span::NTuple{2, Real}, m::Union{Nothing, <:AbstractMonitor}=nothing)\n\nMap x forward/backward over a time span (span[1], span[2]) using the nonlinear trajectory stored in s to drive linearised equations. An additional Monitor object m can be filled along the way. The monitor object is fed with elements that are  similar to x. This method can be used to integrate forward or  adjoint equations in a way that is not discretely consistent.\n\n\n\n\n\n","category":"type"},{"location":"api/#Monitor-API-1","page":"Full API","title":"Monitor API","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"Monitor\nreset!\ntimes\nsamples","category":"page"},{"location":"api/#Flows.Monitor","page":"Full API","title":"Flows.Monitor","text":"Monitor(x, f::Base.Callable=identity, store::S=RAMStorage(f(x)); oneevery::Int=1, savebetween::Tuple{Real, Real}=(-Inf, Inf), sizehint::Int=0)\n\nConstruct a Monitor object to record one observable quantity along a trajectory. \n\nThe argument x is an object of the same type used to represent the system's state,  while f is a callable object or function that calculates the observable from the state.  In other words, the quantity f(x) is monitored along a trajectory, and stored in  store, which defaults to a RAMStorage object. One sample every onevery  samples is stored.\n\nIf required, only samples at times falling in the range specified by savebetween are  stored. Specifying the number of samples stored with the sizehint keyword argument may increase performance.\n\nA Monitor object can then be passed as an additional argument to a Flows.Flow object.\n\nSee also reset!, times and samples.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.reset!","page":"Full API","title":"Flows.reset!","text":"reset!(mon::Monitor, sizehint::Int=0)\n\nReset the internal storage of a Monitor object mon.\n\n\n\n\n\n","category":"function"},{"location":"api/#Flows.times","page":"Full API","title":"Flows.times","text":"times(mon::Monitor)\n\nReturn the times at which samples of the observable have been stored. This is most  typically after each time step, in addition to the initial condition. The type of the  returned object depend on the internal storage. For RAMStorage storages, this is a standard Vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#Flows.samples","page":"Full API","title":"Flows.samples","text":"samples(mon::Monitor)\n\nReturn samples of the observable that have been stored during a trajectory. This is most  typically after each time step, in addition to the initial condition. The type of the  returned object depend on the internal storage. For RAMStorage storages, this is a standard Vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#Coupled-API-1","page":"Full API","title":"Coupled API","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"Coupled\ncouple\ncouplecopy\ngetindex\nsimilar\nsize","category":"page"},{"location":"api/#Flows.Coupled","page":"Full API","title":"Flows.Coupled","text":"Coupled{N, ARGS<:NTuple{N, Any}} <: AbstractVector{Any}\n\nCouple together N objects and store them internally in a Julia ntuple of size N.\n\nCoupledobjects are immutable, but their elements must be mutable, allowing the  content to be modified. The individual elements of aCoupledobject can be  accessed using the standard indexing notation, but the elements cannot be changed, i.e. there is noBase.setindex!defined forCoupled` objects.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.couple","page":"Full API","title":"Flows.couple","text":"couple(args...)\n\nCreate a Coupled object from the sequence of arguments args. \n\n\n\n\n\n","category":"function"},{"location":"api/#Flows.couplecopy","page":"Full API","title":"Flows.couplecopy","text":"couplecopy(N::Int, x)\n\nCouple N copies of x together, created using Base.deepcopy.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.getindex","page":"Full API","title":"Base.getindex","text":"Base.getindex(x::Coupled, i::Int)\n\nReturn the i-th element of a Coupled object. \n\n\n\n\n\n","category":"function"},{"location":"api/#Base.similar","page":"Full API","title":"Base.similar","text":"Base.similar(x::Coupled)\n\nCall Base.similar on the elements of x and couple them together in a new object.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.size","page":"Full API","title":"Base.size","text":"Base.size(::Coupled{N}) where {N}\n\nReturn (N, ), the size of a Coupled{N} object, coupling N elements together.\n\n\n\n\n\n","category":"function"},{"location":"api/#Storage-API-1","page":"Full API","title":"Storage API","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"RAMStorage\nperiod\nisperiodic\ntimespan","category":"page"},{"location":"api/#Flows.RAMStorage","page":"Full API","title":"Flows.RAMStorage","text":"empty\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.period","page":"Full API","title":"Flows.period","text":"period(rs::RAMStorage)\n\nReturn the period of the data, or 0 if the data in non periodic.\n\n\n\n\n\n","category":"function"},{"location":"api/#Flows.isperiodic","page":"Full API","title":"Flows.isperiodic","text":"isperiodic(rs::RAMStorage)\n\nReturn true if the data stored in rs represent a periodic signal.\n\n\n\n\n\n","category":"function"},{"location":"api/#Flows.timespan","page":"Full API","title":"Flows.timespan","text":"timespan(rs::RAMStorage)\n\nReturn a 2-tuple with the first and last times stored.\n\n\n\n\n\n","category":"function"},{"location":"api/#Integration-methods-API-1","page":"Full API","title":"Integration methods API","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"RK4\nCNRK2\nCB3R2R2\nCB3R2R3c\nCB3R2R3e\nCB4R3R4\nImcA!","category":"page"},{"location":"api/#Flows.RK4","page":"Full API","title":"Flows.RK4","text":"RK4(x::X, mode::AbstractMode=NormalMode())\n\nConstructs a RK4 integration scheme object for integration with mode mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.CNRK2","page":"Full API","title":"Flows.CNRK2","text":"CNRK2(x::X, mode::AbstractMode=NormalMode())\n\nConstructs a CNRK2 integration scheme object for integration with mode mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.CB3R2R2","page":"Full API","title":"Flows.CB3R2R2","text":"CB3R2R2(x::X, mode::AbstractMode=NormalMode())\n\nConstructs a CB3R2R2 integration scheme object for integration with mode mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.CB3R2R3c","page":"Full API","title":"Flows.CB3R2R3c","text":"CB3R2R3c(x::X, mode::AbstractMode=NormalMode())\n\nConstructs a CB3R2R3c integration scheme object for integration with mode mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.CB3R2R3e","page":"Full API","title":"Flows.CB3R2R3e","text":"CB3R2R3e(x::X, mode::AbstractMode=NormalMode())\n\nConstructs a CB3R2R3e integration scheme object for integration with mode mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.CB4R3R4","page":"Full API","title":"Flows.CB4R3R4","text":"CB4R3R4(x::X, mode::AbstractMode=NormalMode())\n\nConstructs a CB4R3R4 integration scheme object for integration with mode mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.ImcA!","page":"Full API","title":"Flows.ImcA!","text":"ImcA!(A, c::Real, y, z)\n\nReturn z that solves the linear problem (I - c*A)*z = y, where c is a scalar,  A a linear operator and I is the identity. \n\nTo use the IMEX schemes in this package, user should add methods to this function for  their custom types, using an efficient implementation. A default implementation when  A is of type LinearAlgebra.Diagonal and y and z is provided by this package.\n\nNotes\n\nThe name of this function should be read \"I-minus-see-A\".\n\n\n\n\n\n","category":"function"},{"location":"api/#Time-Stepping-API-1","page":"Full API","title":"Time Stepping API","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"TimeStepConstant\nTimeStepFromStorage\nAbstractTimeStepFromHook","category":"page"},{"location":"api/#Flows.TimeStepConstant","page":"Full API","title":"Flows.TimeStepConstant","text":"TimeStepConstant(Δt::Real)\n\nSpecify that integration should be performed with constant time step Δt.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.TimeStepFromStorage","page":"Full API","title":"Flows.TimeStepFromStorage","text":"TimeStepFromStorage(Δt::Real)\n\nSpecify that integration should be performed with constant time step Δt, and  that an AbstractStorage will be required.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.AbstractTimeStepFromHook","page":"Full API","title":"Flows.AbstractTimeStepFromHook","text":"AbstractTimeStepFromHook\n\nAbstract type for time stepping schemes where the time step is determined at runtime.\n\nSee Flows.jl Adaptive time stepping\n\n\n\n\n\n","category":"type"},{"location":"storage/#Solution-storages-1","page":"Solution storages","title":"Solution storages","text":"","category":"section"},{"location":"storage/#Storing-the-solution-in-RAM-1","page":"Solution storages","title":"Storing the solution in RAM","text":"","category":"section"},{"location":"available-methods/#Available-integration-schemes-1","page":"Available methods","title":"Available integration schemes","text":"","category":"section"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"Currently only a handful of integration schemes are supported. These are:","category":"page"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"RK4, a classical fourth order Runge-Kutta method, for non-stiff problems\na set of low-storage IMEX method developed by Daniele Cavaglieri and Thomas Bewley at UCSD [1] for stiff problems, where stiffness arises from the linear term\nCB3R2R2, a second order accurate method\nCB3R2R3e and CB3R2R3c, two third order accurate methods \nCB4R3R, a fourth order accurate method\nCNRK2, a classical second order Crank-Nicholson-Runge-Kutta method for stiff problems","category":"page"},{"location":"available-methods/#Usage-1","page":"Available methods","title":"Usage","text":"","category":"section"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"All methods have constructors with similar signatures.","category":"page"},{"location":"available-methods/#Standard-problems-and-coupled-systems-1","page":"Available methods","title":"Standard problems and coupled systems","text":"","category":"section"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"For standard problems including coupled systems, the constructor accepts an object of the type used to represent the state (see Flows.jl Defining the integration scheme). For instance, to construct an RK4 object for a system defined by a 4times 4 Julia Matrix type","category":"page"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"m = RK4(zeros(4, 4))","category":"page"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"For Flows.jl Coupled dynamical systems, the object passed two the constructor should be a Coupled object, consistent with the state type.","category":"page"},{"location":"available-methods/#Linearised-equations-1","page":"Available methods","title":"Linearised equations","text":"","category":"section"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"For linearised equations marched over an AbstractStorage the constructor accepts an additional argument, depending on whether the equations correspond to a forward or adjoint problem. An RK4 method for the forward problem with the same type as discussed before is constructed as","category":"page"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"m = RK4(zeros(4, 4), ContinuousMode(false))","category":"page"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"while for the adjoint problem","category":"page"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"m = RK4(zeros(4, 4), ContinuousMode(true))","category":"page"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"The object ContinuousMode signals that we are solving a continuous approximation of the linearised equations. Discrete adjoint solvers are planned, but not implemented yet.","category":"page"},{"location":"available-methods/#References-1","page":"Available methods","title":"References","text":"","category":"section"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"[1] Cavaglieri, D. and Bewley, T., 2015. Low-storage implicit/explicit Runge–Kutta schemes for the simulation of stiff high-dimensional ODE systems. Journal of Computational Physics, 286, pp.172-193.","category":"page"},{"location":"quickstart/#Quick-start-1","page":"Quick Start","title":"Quick start","text":"","category":"section"},{"location":"quickstart/#Fundamentals-1","page":"Quick Start","title":"Fundamentals","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Thorughout this package we consider dynamical systems defined by an evolution equation of the type","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"dotmathbfx(t) = mathcalLmathbfx(t) + mathbff(t mathbfx(t))","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"where t is time and mathbfx is the state, an element of some space mathcalX. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"The operator mathcalL is linear and time invariant and contains stiff terms that are advanced implictly in time. The function mathbff(t mathbfx(t)) is a nonlinear term that is advanced using an explicit scheme. This notation is purely operational: if the dynamical system does not have any stiff terms and can be advanced using an explicit scheme, all terms can be lumped into the function mathbff(t mathbfx(t)).","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"In many situations in dynamical systems theory, one requires the flow of the vector field mathbff, the nonlinear operator mathbfPhi^t  mathcalX mapsto mathcalX mapping the state mathbfx_0 at t=t_0 to its forward-in-time image mathbfx(t). Mathematically, this operation is","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"mathbfx(t) = mathbfPhi^t-t_0 mathbfx_0","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"The structure of this package, and the API it provides, is entirely based on satisfying this flow interface, where a Flow object is constructed that acts as the time discrete version of mathbfPhi.","category":"page"},{"location":"quickstart/#User-interface-1","page":"Quick Start","title":"User interface","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"To construct a Flow object, the user needs to write Julia code for the state object mathbfx and for the right-hand-side mathbff, in addition to specifing what integration scheme will be used to advance the state in time.","category":"page"},{"location":"quickstart/#Defining-state-objects-1","page":"Quick Start","title":"Defining state objects","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"The package works transparently on state objects x of arbitrary Julia type, say objects of some user defined Julia type X that might loosely map to their mathematical equivalent mathcalX and which may provide some advanced API. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"State objects represented by a standard Julia AbstractArrays (of any dimension) work out-of-the-box. However, the requirement of expressing computations with object of type AbstractArray, or even just Vector, can be quite restrictive in practice and would not leverage the multiple dispatch capabilities of Julia. As an example, consider solving a time dependent partial differential equation over a one-dimensional domain using a Fourier-Galerkin method. The user might wish to define a SpectralField type representing fields, with a custom API for, e.g., computing the derivative field. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"struct SpectralField{T<:AbstractFloat}\n    data::Vector{Complex{T}}\nend\n\nddx(u::SpectralField) = # some definitions\n","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"To work with the package, user types should satisfy these two requirements:","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"support dot-broadcasting in in-place algebraic expressions including scalars and objects of the same type. For instance, notation like x .= 3.0.*y .+ 4.0.*z for three elements x, y and z of the user type should be supported.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"provide methods for Base.similar(x) and Base.copy(x).","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Internally, the package makes extensive use of the dot notation, when updating cache objects during a time step. The restriction prevents having immutable StaticArrays objects as state objects, which would probably lead to faster code on small problems. This is less important for the intended applications of this package, i.e. turbulent flow simulations where the state is generally given by multiple large three-dimensional arrays and having mutable objects is important for performance.","category":"page"},{"location":"quickstart/#Defining-the-right-hand-side-1","page":"Quick Start","title":"Defining the right hand side","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Given a state x as an object of type X, the steps required to specify the right hand side depend on whether an explicit or semi-implicit integration method is used.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"For explicit methods, a dynamical system is specified by a Julia function or some other callable object that has a method with signature","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"f(t::Real, x::X, dxdt::X) where {X}","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"This function is supposed to operate in place and should modify the content of the third argument dxdt with the time derivative at x, and if needed, time t. Modifying the content of the second argument in the body of this function is undefined behaviour. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"example: Example\nConsider defining a custom type implementing the right-hand-side of the Lorenz equations. A Julia type is defined with one field for the parameter rho:struct Lorenz \n    ρ::Float64\n    Lorenz(ρ::Real = 28.0) = new(ρ)\nendThen, the type is made callable by defining the following method:function (eq::Lorenz)(t, u, dudt)\n    x, y, z = u\n    dudt[1] =  10 * (y - x)\n    dudt[2] =  eq.ρ *  x - y - x*z\n    dudt[3] = -8/3 * z + x*y\n    return dudt\nendNote how this function returns the argument that has been modified. This is not required by the package API, but can be useful in other situations.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"The semi-implicit methods that are currently implemented assume that the stiff term is linear and given by an time-invariant operator mathcalL. To define this term, the user must define a Julia type, say A, with a method for the LinearAlgebra function mul!, with signature","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"LinearAlgebra.mul!(out::X, a::A, x::X)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"which computes the action of a on x and stores it in out. Modifying the content of x is undefined behaviour. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"In addition, the type A should have a method for the function Flows.ImcA, provided by this package, with signature","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Flows.ImcA(a::A, c::Real, y::X, z::X)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"to solves the linear system ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"    (a - c I)z = y","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"for some right hand side y of type X and a scalar c and stores the result in z, again of type X.","category":"page"},{"location":"quickstart/#Defining-the-integration-scheme-1","page":"Quick Start","title":"Defining the integration scheme","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Performing a time step typically requires temporary objects for intermediate computations, e.g. the internal stages of a Runge-Kutta method. In this package, these temporary objects are pre-allocated by creating an helper object, an instance of one of the concrete subtypes of AbstractMethod provided by the package (see Available integration schemes).","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"All constructors of such helper objects have the same signature and require a single argument of type X. This argument is used internally in the constructor to to pre-allocate as many similar similar objects as needed for the intermediate computations in the time step. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"example: Example\nConsider using the classical fourth-order Runge-Kutta method to integrate the Lorenz equations defined above. The state vector is implemented using a standard Julia Vector of three elements, and the helper object is constructed bymethod = RK4(zeros(3))","category":"page"},{"location":"quickstart/#Defining-the-time-stepping-method-1","page":"Quick Start","title":"Defining the time stepping method","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Once the integration scheme is defined, the user needs to specify a time stepping method. This is essentially a specification of how time steps should be selected to advance the state forward in time. This package provides different methods, but for the purpose of this quick start document, we only document one of the most used, TimeStepConstant. As the name suggested, this method indicates that the time step should be constant and equal to a value specified at construction. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"This is achieved by constructing a TimeStepConstant object as:","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"steps = TimeStepConstant(0.1)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"which signals that a constant time step Delta t = 01 will be used in the integration.","category":"page"},{"location":"quickstart/#Finally-defining-the-flow-operator-1","page":"Quick Start","title":"Finally defining the flow operator","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"With state, dynamical system, integration method and time stepping defined, we are finally ready to define the flow operator. This is achieved by using the flow function, which constructs a Flow object. It has two methods, with signature","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"flow(f::Any, method::AbstractMethod, stepping::AbstractTimeStepping)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"and ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"flow(f::Any, L::Any, method::AbstractMethod, stepping::AbstractTimeStepping)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"for problems that are integrated using explicit or semi-implicit methods, respectively.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"A Flow object is callable with the signature ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"(::Flow)(x::X, span::Tuple{Real, Real})","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"and propagates the state object x from time span[1] to a later time span[2], returning its first argument. The key observation is that for performance reasons the flow operator operates in place and overwrites its first argument. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"example: Example\nThis example demonstrates how to construct a Flow object approximating the flow of the Lorenz equations (defined above) using a classical fourth-order Runge-Kutta scheme with constant time step Delta t = 01.The Flow object is constructed byF = flow(Lorenz(28), RK4(zeros(3)), TimeStepConstant(1e-2))A point on the attractor can be then obtained by propagating a random initial conditions by some amount of time ```julia x = F(rand(3), (0, 100))","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Adjoint-Sensitivity-1","page":"Examples","title":"Adjoint Sensitivity","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Variational techniques and adjoint methods can sometimes feel quite difficult to the novice, since sophisticated mathematical concepts (function spaces, functionals, etc) are often introduced at an early stage. The use of such advanced concepts, however, provides a robust basis and can often clarify the meaning and value of adjoint equations [1].","category":"page"},{"location":"examples/#Fundamentals-1","page":"Examples","title":"Fundamentals","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"To show how adjoint sensitivity methods can be used in this package we will consider an optimal control problem on a toy model, given by the initial value problem","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"labeleqtag1\nleft\nbeginarrayrl\ndotx(t) = x(t)^2 + u(t)quad t in 0 T\nx(0) = x_0\nendarray\nright","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"where both the solution x(t) and control u(t) are assumed to be elements of the function space mathcalS, the space of square-integrable continuous functions mapping the interval 0 T to mathbbR. We endow this space with the inner product","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"langle v(t) w(t)rangle = int_0^T v(t)w(t)mathrmdt","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Now consider the objective functional","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"hatmathcalJx(t) u(t) = int_0^T sin(x(t)) mathrmdt","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"mapping two elements of mathcalS to mathbbR. Because x(t) and u(t) are related by the initial value problem (refeq), we consider the reduced functional ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"mathcalJu(t) = int_0^T sin(x(t)) mathrmdt","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"mapping one element of mathcalS to mathbbR, where x(t) is assumed to be the solution of (refeq). The goal is find the gradient of the reduced functional with respect to the control u(t), denoted by ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"mathrmdmathcalJ   mathrmdu(t)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"If gradient information is available, gradient descent can be used to optimise the controls and extremise the objective functional. ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"To this end, we proceed by first considering an small, arbitrary perturbation to the controls v(t) in mathcalS, producing a small change in the solution of the initial value problem, denoted by y(t) in mathcalS and obeying the linear problem","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"labeleqlinear-eqtag2\nleft\nbeginarrayrl\ndoty(t) = 2x(t)y(t) + v(t)\ny(0) = 0\nendarray\nright","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"where y(t) is initially set to zero because the initial condition of problem (refeq) is assumed not to change when the controls are varied. This is an optimal control problem: we simply wish to modify the future evolution of a system by appropriately tuning the controls, from the same initial state.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Now, because of this perturbation y(t), the reduced functional will change by a small amount. Linearising its definition shows that this change can be expressed by a new functional","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"mathcalJ_u(t)v(t) = int_0^T cos(x(t)) y(t) mathrmdt","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"This notation should read: if the controls u(t) are perturbed by a small amount v(t), the change in the objective functional will be expressed by the integral at the right hand side, where y(t) is obtained from the solution of the linearised equations (refeqlinear-eq). In fact, this functional defines the directional derivative, the change of some function along a specified direction. ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"To obtain the gradient, let's introduce a function q(t) in mathcalS and consider the identity","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"langle q(t) doty(t) - 2x(t)y(t) - v(t) rangle = 0","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"where y(t) is a solution of the linearised problem (refeqlinear-eq). We can add this term to the linear functional mathcalJ_u(t)v(t) obtaining","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"mathcalJ_u(t)v(t) = int_0^T cos(x(t))y(t) + q(t)doty(t) - 2x(t)y(t) - v(t)  mathrmdt","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"without having changed anything. However, integrating by parts the term q(t)doty(t) and collectin products of y(t) leads to ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"mathcalJ_u(t)v(t) = - int_0^T q(t)v(t) mathrmdt + int_0^T y(t)cos(x(t)) - dotq(t) - 2q(t)x(t)mathrmdt + q(T)y(T) - q(0)y(0)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"If we now specify that the adjoint function q(t) satisfies the initial value problem","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"left\nbeginarrayrl\ndotq(t) = 2x(t)q(t) - cos(x(t))\nq(T) = 0\nendarray\nright","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"the second and third term vanish identically, since y(0) is zero. The interesting thing about the adjoint problem (a linear problem) is that the initial condition is specified at the final time. This is not an issue per se, it just means that instead of marching the equations forward in time, as we would do to solve (refeq), we will have to proceed backwards. However, we can notice that the adjoint equation depends on the solution x(t), which is obtained by marching the equations forward in time. The practical solution is that we will need to store the entire solution x(t) in memory (and possibly interpolate it) to solve the adjoint problem. This is not an issue in this toy problem, but it can be quite onerous for simulations of large-scale systems, e.g. direct simulation of turbulent flows.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"With these steps we obtain an expression for the directional derivative","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"tag3labeldirectional-derivative\nmathcalJ_u(t)v(t) = langle - q(t)v(t)rangle = int_0^T - q(t)v(t) mathrmdt","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"that does not contain y(t), only the perturbation to the controls. Now, there is a theorem, called the Riesz Representation Theorem, that can help us reading the gradient from this expression. In our setting, the theorem states that any linear functional can be represented as the inner product with an element of mathcalS. If mathcalL is one of such functionals, there exist an element v_mathcalL(t) of mathcalS such that","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"mathcalLv(t) = langle v_mathcalL(t) v(t) rangle = int_0 ^T v_mathcalL(t)v(t)mathrmdt","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Comparing (refdirectional-derivative) with the basic definition of the directional derivative shows that the gradient is simply","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"tag4labelgradient\nmathrmdmathcalJmathrmdu(t) = - q(t)","category":"page"},{"location":"examples/#Hands-on-1","page":"Examples","title":"Hands on","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"We now show how to set up and solve the adjoint problem derived in the previous section using this package [2].  First, we discretise functions in mathcalF by introducing a uniform temporal mesh given by N+1 times t_i = (i-1) Delta t, i=1 N+1, with Delta t = TN. Without loss of generality, let us take T=1, so that the mesh is defined by the Julia range","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"ti = 0:0.01:1","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"An element u(t) of mathcalS will thus be discretised into a Julia Vector of N+1 elements, denoted by u with u(t_i)=u[i]. ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The first ingredient is that we need code to solve the initial value problem (refeq) for any arbitrary control u(t). This can be achieved by introducing a custom type NonLinearSystem defined as","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"struct NonLinearSystem{U}\n    _u::U\n    function NonLinearSystem(ti::AbstractVector, u::AbstractVector)\n        # construct interpolator from t and u\n        _u = interp(ti, u)\n        return new{typeof(_u)}(_u)\n    end\nend","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Here, interp is some Julia function (not defined here) that interpolates the function given by the Julia Vectors ti and u at any arbitrary time, e.g. using a linear interpolation scheme. We need this interpolator since the time stepping scheme might call the rigth hand side in (refeq) at times in between the available mesh points. Code that evaluates the right hand side is, for instance, ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"function (sys::NonLinearSystem)(t, x, dxdt)\n    dxdt[1] = x[1]^2 + sys._u(t)\n    return nothing\nend","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Note how we call the interpolator sys._u at the input time t.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"We now need code to solve the adjoint problem. This can again be achieved by introducing a custom Julia type, AdjointSystem, defined as","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"struct AdjointSystem{X}\n    _x::X\n    function AdjointSystem(ti::AbstractVector, x::AbstractVector)\n        # construct interpolator from t and x\n        _x = interp(ti, x)\n        return new{typeof(_x)}(_x)\n    end\nend","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"where the constructor requires a vector of times ti and a vector of solution points x. These are used in the constructor to build an interpolator _x so that we can have access to the state x(t) while marching the adjoint equation backwards.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The right hand side of the adjoint problem can be coded up in this way:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"function (sys::AdjointSystem)(t, q, dqdt)\n    x = sys._x(t)\n    dqdt[1] = 2*x*q[1] - cos(x)\n    return nothing\nend","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"where we first interpolate the solution x(t) and then evaluate the right hand side.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"So far, we have only seen user code, and not really how to use this package. Hence, we first define the forward problem, by constructing a right hand side (with zero control)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"f = NonLinearSystem(ts, zeros(ti))","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"and then defining its associated flow operator ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"F = flow(f, RK4(zeros(1)), TimeStepConstant(0.01))","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"constructed using a Runge-Kutta integration method. Note how the state is represented by a one element Vector, since state object must be mutable in this package. To obtain the forward solution, we define a monitor extracting the first component","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"mon_F = Monitor(zeros(1), x->x[1])","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"and then solve the problem forward from some initial condition x0 = Float64[1.0] by","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"F(x0, extrema(ts), mon)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The Monitor object now contains samples of the state at the end of every time step. We can use these samples to define the adjoint system","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"g = AdjointSystem(ts, samples(mon))","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"and then the adjoint flow operator","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"G = flow(f, RK4(zeros(1), ContinuousMode(), true), TimeStepConstant(0.01))","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Note how","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"the RK4 is passed extra arguments, true indicating that we have an adjoint problem, to be marched backwards.\nthe time step, 0.01, is constant and positive.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"With the adjoint flow operator defined, we can now solve the adjoint problem. We first define a Monitor to observe the adjoint solution, flipping its sign to be compatible with the definition of the gradient (refgradient)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"mon_G = Monitor(zeros(1), q -> - q[1])","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"To obtain the gradient, we march the equations backwards in time from a zero terminal condition","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"G(zeros(0), reverse(extrema(ts)), mon_G)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"and get the gradient by samples(mon_G). ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"[1]: The exposition is meant to be illustrative and mostly addressed to the author's students having to learn this material to complete their project","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"[2]: Note that the approach implemented in this package is the diffentiate-then-discretize.","category":"page"},{"location":"monitors/#Monitor-objects-1","page":"Monitors","title":"Monitor objects","text":"","category":"section"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"A Flow (see Flows.jl Quickstart for an introduction) operator simply maps a state vector forward in time by some specified amount. It operates in place, and does not store or record anything during the trajectory. However, it is sometimes useful to record some quantity, for instance one of the degrees of freedom, or maybe some integral quantity along a trajectory. This can be achieved by using a Monitor object.","category":"page"},{"location":"monitors/#Basic-usage-1","page":"Monitors","title":"Basic usage","text":"","category":"section"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"The constructor of the Monitor type has the signature","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"Monitor(x::X, g::Union{Callable, Function})","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"The first argument is an object of some user defined type, say X, the same type used to represent the system's state. The second argument is a function or callable object that we use to 'observe' the state along the simulation. It must accept a single argument of type X, must have the signature","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"g(::X)","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"and can return anything. ","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"example: Example\nThis example demonstrates how to define an object to monitor the first state of a dynamical system with three degrees of freedom.mon = Monitor(zeros(3), x->x[1])Note how the second argument is simply an anonymous function that extracts the first element. A more elegant approach is alsomon = Monitor(zeros(3), first)","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"In practice, in the constructor, the function is called on the first argument, the type of the output is analysed and storage to hold more elements of the same type is allocated.","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"To monitor an observable during a trajectory, the monitor object can be passed as a third argument to a Flow object. During the integration, a sample of the observable is taken at the end of every time step, including one sample at the beginning of the trajectory.","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"example: Example\nFor instance, assume F is a Flow object for the Lorenz equations and we want to monitor the norm of the state vector over a short trajectory from t=0 to t=1. This can be achieved bymon = Monitor(zeros(3), norm)\nF(x, (0, 1), mon)","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"At the end of the integration, the content of the Monitor object mon can be accessed by two helper functions. The first","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"samples(mon)","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"returns a Julia Vector with samples of the observed function, while ","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"times(mon)","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"returns a Vector containing the times whan the samples are taken. This can be used, for instance, to plotting the observable as a function of time.","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"note: Note\nThe observable function can really return anything. For instance, if we want to observe the full state, we can define a monitor with the copy function.mon = Monitor(zeros(3), copy)\nF(x, (0, 1), mon)If we want to monitor more quantities, we can pass a function that returns a Tuple, like somon = Monitor(zeros(3), x->(x[1], x[2]^2))\nF(x, (0, 1), mon)so that samples(mon) returns a vector of Tuples.","category":"page"},{"location":"monitors/#Advanced-usage-1","page":"Monitors","title":"Advanced usage","text":"","category":"section"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"The behaviour of Monitor object can be customised more finely. Consult the Monitor API page for more details.","category":"page"},{"location":"#Flows.jl-1","page":"Home","title":"Flows.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A flow-like API to solve differential equations. ","category":"page"},{"location":"#Rationale-1","page":"Home","title":"Rationale","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Many numerical algorithms in dynamical systems theory require the action of a flow operator associated to a dynamical system, rather than a solve-an-initial-value-problem-and-store-its-solution approach. This package provides an API geared towards this needs, without the ambition to be a general purpose package.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package is not registerd in the Julia's METADATA.jl but can be installed in the Julia REPL. First, hit ] to enter package mode, then type","category":"page"},{"location":"#","page":"Home","title":"Home","text":"add https://github.com/gasagna/Flows.jl","category":"page"},{"location":"#Table-of-Contents-1","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"quickstart.md\", \"monitors.md\", \"available-methods.md\", \"coupled.md\", \"quadrature.md\", \"examples.md\", \"advanced.md\", \"api.md\",]\nDepth = 1","category":"page"}]
}
