var documenterSearchIndex = {"docs":
[{"location":"api/#Flows.jl-API-1","page":"Full API","title":"Flows.jl API","text":"","category":"section"},{"location":"api/#The-Flow-operator-1","page":"Full API","title":"The Flow operator","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"The basic building block of this package is the Flows.Flow object, a discrete approximation of the flow of a dynamical system. Here is a list of possible constructors.","category":"page"},{"location":"api/#","page":"Full API","title":"Full API","text":"flow","category":"page"},{"location":"api/#Flows.flow","page":"Full API","title":"Flows.flow","text":"flow(g, m::AbstractMethod, ts::AbstractTimeStepping)\n\nConstruct an object of type Flow, representing the numerical dicretisation of the time-forward flow operator associated to the vector field g, using the integration method m, with time stepping provided by ts. This method should be used with an explicit integration method.\n\n\n\n\n\nflow(g, A, m::AbstractMethod, ts::AbstractTimeStepping)\n\nConstruct a flow operator associated to the vector field defined by a linear component A and a nonlinear part g. An implicit-explicit integration  method m should be provided. \n\n\n\n\n\nflow(g::Coupled{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}\n\nConstruct a flow operator associated to the composite vector field g, using a default call dependency structure, i.e. where the elements of g satisfy the calling interface:\n\ng[1](t, u[1], dudt[1])\ng[2](t, u[1], dudt[1], u[2], dudt[2]) ...\ng[N](t, u[1], dudt[1], u[N], dudt[N])\n\nSee Flows.jl Call Dependencies for more details on how to specify custom call dependencies. This method should be used with an explicit integrator.\n\n\n\n\n\nflow(g::Coupled{N}, spec::CallDependency{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}\n\nSimilar to the method without spec, but specifying a custom call dependency structure.\n\n\n\n\n\nflow(g::Coupled{N}, A::Coupled{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}\n\nSimilar to previous methods, but also provide the linear part of the dynamical system. This method should be used with an implicit-explicit integrator.\n\n\n\n\n\nflow(g::Coupled{N}, A::Coupled{N}, spec::CallDependency{N}, m::AbstractMethod, ts::AbstractTimeStepping) where {N}\n\nSimilar to previous methods, but provide a custom call dependency structure. This method should be used with an implicit-explicit integrator.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"Full API","title":"Full API","text":"Objects of type Flow satisfy a callable interface, with additional arguments possible.","category":"page"},{"location":"api/#","page":"Full API","title":"Full API","text":"Flows.Flow","category":"page"},{"location":"api/#Flows.Flow","page":"Full API","title":"Flows.Flow","text":"(I::Flow)(x, span::NTuple{2, Real})\n\nMap x at time span[1] to the later time span[2]. \n\nThe object x is modified in place. The argument x shoule be of a type  compatible to that used to create the integration method object for the Flow object I, since the integration method contains preallocated elements used  to perform the integration step.\n\n\n\n\n\n(I::Flow)(x, span::NTuple{2, Real}, m::AbstractMonitor)\n\nMap x at time span[1] to the later time span[2], filling the monitor obejct m along the way. See Flow.jl Monitor objects for more details on how to define and use Monitor objects.\n\n\n\n\n\n(I::Flow)(x, span::NTuple{2, Real}, c::AbstractStageCache)\n\nMap x at time span[1] to the later time span[2], filling the stage cache obejct c along the way. See Flow.jl Stage Caches for more details on how to define and use AbstractStageCache objects.\n\n\n\n\n\n(I::Flow)(x, span::NTuple{2, Real}, s::AbstractStorage)\n\nMap x at time span[1] to the later time span[2], filling the storage  object s along the way. This method is used primarily to fill a storage  object with the results of a nonlinear simulation, where the storage s can be subsequently used for the linearised systems. See Flow.jl Storages  for more details on how to define and use AbstractStorage objects.\n\n\n\n\n\n(I::Flow{TimeStepFromCache})(x, c::AbstractStageCache, m::Union{Nothing, <:AbstractMonitor}=nothing)\n\nMap x forward/backward over a time span defined by the stage cache object c,  filling the monitor object m along the way. This method is primarily used to  integrate linearised equations forward/backward, so that the nonlinear and  linearised methods are discretely consistent. See Flow.jl Stage Caches  for more details on how to define and use AbstractStorage objects.\n\n\n\n\n\n(I::Flow{TimeStepFromStorage})(x, s::AbstractStorage, span::NTuple{2, Real}, m::Union{Nothing, <:AbstractMonitor}=nothing)\n\nMap x forward/backward over a time span (span[1], span[2]) using the nonlinear trajectory stored in s to drive linearised equations. An additional Monitor object m can be filled along the way. The monitor object is fed with elements that are  similar to x. This method can be used to integrate forward or  adjoint equations in a way that is not discretely consistent.\n\n\n\n\n\n","category":"type"},{"location":"api/#Monitor-objects-1","page":"Full API","title":"Monitor objects","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"Monitor\nreset!\ntimes\nsamples","category":"page"},{"location":"api/#Flows.Monitor","page":"Full API","title":"Flows.Monitor","text":"Monitor(x, f::Base.Callable=identity, store::S=RAMStorage(f(x)); oneevery::Int=1, savebetween::Tuple{Real, Real}=(-Inf, Inf), sizehint::Int=0)\n\nConstruct a Monitor object to record one observable quantity along a trajectory. \n\nThe argument x is an object of the same type used to represent the system's state,  while f is a callable object or function that calculates the observable from the state.  In other words, the quantity f(x) is monitored along a trajectory, and stored in  store, which defaults to a RAMStorage object. One sample every onevery  samples is stored.\n\nIf required, only samples at times falling in the range specified by savebetween are  stored. Specifying the number of samples stored with the sizehint keyword argument may increase performance.\n\nA Monitor object can then be passed as an additional argument to a Flows.Flow object.\n\nSee also reset!, times and samples.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.reset!","page":"Full API","title":"Flows.reset!","text":"reset!(mon::Monitor, sizehint::Int=0)\n\nReset the internal storage of a Monitor object mon.\n\n\n\n\n\n","category":"function"},{"location":"api/#Flows.times","page":"Full API","title":"Flows.times","text":"times(mon::Monitor)\n\nReturn the times at which samples of the observable have been stored. This is most  typically after each time step, in addition to the initial condition. The type of the  returned object depend on the internal storage. For RAMStorage storages, this is a standard Vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#Flows.samples","page":"Full API","title":"Flows.samples","text":"samples(mon::Monitor)\n\nReturn samples of the observable that have been stored during a trajectory. This is most  typically after each time step, in addition to the initial condition. The type of the  returned object depend on the internal storage. For RAMStorage storages, this is a standard Vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#Coupled-objects-1","page":"Full API","title":"Coupled objects","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"Coupled\ncouple\ncouplecopy\ngetindex\nsimilar\nsize","category":"page"},{"location":"api/#Flows.Coupled","page":"Full API","title":"Flows.Coupled","text":"Coupled{N, ARGS<:NTuple{N, Any}} <: AbstractVector{Any}\n\nCouple together N objects and store them internally in a Julia ntuple of size N.\n\nCoupledobjects are immutable, but their elements must be mutable, allowing the  content to be modified. The individual elements of aCoupledobject can be  accessed using the standard indexing notation, but the elements cannot be changed, i.e. there is noBase.setindex!defined forCoupled` objects.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.couple","page":"Full API","title":"Flows.couple","text":"couple(args...)\n\nCreate a Coupled object from the sequence of arguments args. \n\n\n\n\n\n","category":"function"},{"location":"api/#Flows.couplecopy","page":"Full API","title":"Flows.couplecopy","text":"couplecopy(N::Int, x)\n\nCouple N copies of x together, created using Base.deepcopy.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.getindex","page":"Full API","title":"Base.getindex","text":"Base.getindex(x::Coupled, i::Int)\n\nReturn the i-th element of a Coupled object. \n\n\n\n\n\n","category":"function"},{"location":"api/#Base.similar","page":"Full API","title":"Base.similar","text":"Base.similar(x::Coupled)\n\nCall Base.similar on the elements of x and couple them together in a new object.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.size","page":"Full API","title":"Base.size","text":"Base.size(::Coupled{N}) where {N}\n\nReturn (N, ), the size of a Coupled{N} object, coupling N elements together.\n\n\n\n\n\n","category":"function"},{"location":"api/#Storage-objects-1","page":"Full API","title":"Storage objects","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"RAMStorage\nperiod\nisperiodic\ntimespan","category":"page"},{"location":"api/#Flows.RAMStorage","page":"Full API","title":"Flows.RAMStorage","text":"empty\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.period","page":"Full API","title":"Flows.period","text":"period(rs::RAMStorage)\n\nReturn the period of the data, or 0 if the data in non periodic.\n\n\n\n\n\n","category":"function"},{"location":"api/#Flows.isperiodic","page":"Full API","title":"Flows.isperiodic","text":"isperiodic(rs::RAMStorage)\n\nReturn true if the data stored in rs represent a periodic signal.\n\n\n\n\n\n","category":"function"},{"location":"api/#Flows.timespan","page":"Full API","title":"Flows.timespan","text":"timespan(rs::RAMStorage)\n\nReturn a 2-tuple with the first and last times stored.\n\n\n\n\n\n","category":"function"},{"location":"api/#Semi-implicit-methods-1","page":"Full API","title":"Semi-implicit methods","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"ImcA!","category":"page"},{"location":"api/#Flows.ImcA!","page":"Full API","title":"Flows.ImcA!","text":"ImcA!(A, c::Real, y, z)\n\nReturn z that solves the linear problem (I - c*A)*z = y, where c is a scalar,  A a linear operator and I is the identity. \n\nTo use the IMEX schemes in this package, user should add methods to this function for  their custom types, using an efficient implementation. A default implementation when  A is of type LinearAlgebra.Diagonal and y and z is provided by this package.\n\nNotes\n\nThe name of this function should be read \"I-minus-see-A\".\n\n\n\n\n\n","category":"function"},{"location":"api/#Time-Stepping-1","page":"Full API","title":"Time Stepping","text":"","category":"section"},{"location":"api/#","page":"Full API","title":"Full API","text":"TimeStepConstant\nTimeStepFromStorage\nAbstractTimeStepFromHook","category":"page"},{"location":"api/#Flows.TimeStepConstant","page":"Full API","title":"Flows.TimeStepConstant","text":"TimeStepConstant(Δt::Real)\n\nSpecify that integration should be performed with constant time step Δt.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.TimeStepFromStorage","page":"Full API","title":"Flows.TimeStepFromStorage","text":"TimeStepFromStorage(Δt::Real)\n\nSpecify that integration should be performed with constant time step Δt, and  that an AbstractStorage will be required.\n\n\n\n\n\n","category":"type"},{"location":"api/#Flows.AbstractTimeStepFromHook","page":"Full API","title":"Flows.AbstractTimeStepFromHook","text":"AbstractTimeStepFromHook\n\nAbstract type for time stepping schemes where the time step is determined at runtime.\n\nSee Flows.jl Adaptive time stepping\n\n\n\n\n\n","category":"type"},{"location":"available-methods/#Available-numerical-methods-1","page":"Available methods","title":"Available numerical methods","text":"","category":"section"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"We currently support a handful of numerical methods, much less than other serious differential equations packages. More precisely we support:","category":"page"},{"location":"available-methods/#","page":"Available methods","title":"Available methods","text":"a classical fourth order Runge-Kutta method, for non-stiff equations\nsecond, third and fourth order accurate, low-storage IMEX methods developed by Cavalieri and Bewley (JCP 2015) for stiff problems, where stiffnes arises from the linear term.\na classical second order Crank-Nicholson-Runge-Kutta method","category":"page"},{"location":"storage/#Solution-storages-1","page":"Solution storages","title":"Solution storages","text":"","category":"section"},{"location":"storage/#Storing-the-solution-in-RAM-1","page":"Solution storages","title":"Storing the solution in RAM","text":"","category":"section"},{"location":"coupled/#Coupled-dynamical-systems-1","page":"Coupled systems","title":"Coupled dynamical systems","text":"","category":"section"},{"location":"coupled/#Motivation-1","page":"Coupled systems","title":"Motivation","text":"","category":"section"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"In some situations, the state is defined by two or more heterogeneous components, each obeying its own dynamics, but with some components that depend on each other. For instance, consider a problem where the state mathbfz is defined by two components, say mathbfxinmathcalX and mathbfyinmathcalY, as","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"mathbfz = mathbfx mathbfy","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"where now mathbfz in mathcalZ equiv mathcalXtimes mathcalY. Assume the dynamics of mathbfx(t) to be independent from that of mathbfy(t), but that the latter somehow depends on the former. This situation would correspond to the problem","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"left\nbeginarraycc\n  dotmathbfx(t) = mathbff(t mathbfx(t))\n  dotmathbfy(t) = mathbfg(t mathbfx(t) mathbfy(t))\nendarray\nright","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"A possible strategy to solve this problem is to first solve the first differential equation, store its solution, and the use it to solve the second, perhaps using some kind of interpolation if required. Storing a full solution is often not possible or desirable and the two systems must be solved in a coupled manner.","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"example: Example\nA notable example is the solution of the linearised variational equations, governing the evolution of small perturbations to the initial conditions of an initial value problem. If mathbfx(t) denotes the system's state governed by a nonlinear differential equation and mathbfy(t) denotes the perturbation, the two components obey the coupled problemleft\nbeginarrayc\n  dotmathbfx(t) = mathbff(t mathbfx(t))\n  dotmathbfy(t) = mathbff_mathbfx(t mathbfx(t))cdotmathbfy(t)\nendarray\nrightwhere mathbff_mathbfx is the jacobian of mathbff.","category":"page"},{"location":"coupled/#Approach-1","page":"Coupled systems","title":"Approach","text":"","category":"section"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"The fundamental tool provided by this package to address this need is the couple function, accepting two or more arguments and returning a Coupled object. This is a compact representation akin to a Julia Tuple object (internally, it is a shallow wrapper to a tuple) and thus behaves similar to it. For instance","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"julia> z = couple(Int[1, 2, 3], Float64[0, 4])\n2-element Coupled{2,Tuple{Array{Int64,1},Array{Float64,1}}}:\n [1, 2, 3]\n [0.0, 4.0]\n\njulia> z[1] # it is indexable\nInt[1, 2, 3]\n\njulia> length(z) # it has a length\n2","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"One feature of Coupled objects is that they support Julia's dot notation and operations are forwarded down to each of the internal components. For instance, code such as ","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"julia> z1 = couple(Int[1, 2, 3], Float64[0, 4]);\njulia> z2 = couple(Int[2, 4, 5], Float64[1, 2]);\njulia> z1 .= z2 .* 2\n2-element Coupled{2,Tuple{Array{Int64,1},Array{Float64,1}}}:\n [4, 8, 10]\n [2.0, 4.0]","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"works as expected, where arithmetic operations are forwarded to the two components. The utility of this behaviour is that the arithmetic operations arising in the computation of a time step, e.g. during internal stages of a Runge-Kutta method, are forwarded to all components.","category":"page"},{"location":"coupled/#Example-1","page":"Coupled systems","title":"Example","text":"","category":"section"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"Assume that we want to solve the problem ","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"left\nbeginarraycc\n  dotmathbfx(t) = mathbff(t mathbfx(t))\n  dotmathbfy(t) = mathbfg(t mathbfx(t) mathbfy(t))\nendarray\nright","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"where the two components mathbfx(t) in mathbbR^3 and mathbfy(t) in mathbbR^2 are represented by standard Julia Vectors, for simplicity. Assume that two Julia functions f and g have been defined, with signatures","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"f(t, x, dxdt)\ng(t, x, dxdt, y, dydt)","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"Note the definition of the second function, and how it maps to the original problem.","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"Assume that an explicit fourth-order Runge-Kutta method, provided by this package's RK4 is used to advance the system. Two steps are neeeded. First, we couple together the Julia functions representing the two components by defining","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"h = couple(f, g)","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"Second, we define a composite RK4 method object with ","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"m = RK4(couple(zeros(3), zeros(2)))","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"where we have passed an instance of the type representing the coupled state, obtained by coupling together two temporary Vectors of the right size.","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"The flow operator can then finally be constructed as","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"F = flow(h, m, TimeStepConstant(0.1))","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"where we have declared that we will march the equations forward with time step Δt = 0.1.","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"The flow operator F can now be called on a composite state object. For instance, we define some initial conditions and march the problem in time, with","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"x0 = Float64[0, 1, 0]\ny0 = Float64[2, 3]\n\nF(couple(x0, y0), (0, 1))","category":"page"},{"location":"coupled/#","page":"Coupled systems","title":"Coupled systems","text":"Because F modifies its first argument in place, the Vectors x0 and y0 are modified by the call to F.","category":"page"},{"location":"quickstart/#Quick-start-1","page":"Quick Start","title":"Quick start","text":"","category":"section"},{"location":"quickstart/#Fundamentals-1","page":"Quick Start","title":"Fundamentals","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Thorughout this package we consider dynamical systems defined by an evolution equation of the type","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"dotmathbfx(t) = mathcalLmathbfx(t) + mathbff(t mathbfx(t))","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"where t is time and mathbfx is the state, an element of some space mathcalX. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"The operator mathcalL is linear and time invariant and contains stiff terms that are advanced implictly in time. The function mathbff(t mathbfx(t)) is a nonlinear term that is advanced using an explicit scheme. This notation is purely operational: if the dynamical system does not have any stiff terms and can be advanced using an explicit scheme, all terms can be lumped into the function mathbff(t mathbfx(t)).","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"In many situations one requires the flow of the vector field mathbff, the nonlinear operator mathbfPhi^t  mathcalX mapsto mathcalX mapping the state mathbfx_0 at t=t_0 to its forward-in-time image mathbfx(t). Mathematically, this operation is","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"mathbfx(t) = mathbfPhi^t-t_0(mathbfx_0)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"The structure of this package, and the API it provides, is entirely based satisfy this flow interface, where a Flow object is constructed that acts as the time discrete version of Phi.","category":"page"},{"location":"quickstart/#What-you-need-to-do-1","page":"Quick Start","title":"What you need to do","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"To define a flow operator, the user needs to define Julia code for the state object mathbfx, for the dynamical system mathbff, and then specify what integration scheme will be used to advance the state in time.","category":"page"},{"location":"quickstart/#Defining-state-objects-1","page":"Quick Start","title":"Defining state objects","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"To satisfy the above interface, the package works transparently on state objects x of arbitrary types, say objects of some user defined Julia type X that maps to their mathematical equivalent mathcalX and which may provide some advanced interface. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"State objects represented by a standard Julia AbstractArray object (of any dimension) work out-of-the-box. However, the requirement of expressing computations with object of type AbstractArray, or even just Vector, can be quite restrictive in practice and would not leverage the multiple dispatch capabilities of Julia. As an example, consider solving a PDE over a one-dimensional domain using a Fourier-Galerkin method. The user might wish to define a SpectralField type representing fields, with a custom API for, e.g., computing the derivative field.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"struct SpectralField{T<:AbstractFloat}\n    data::Vector{Complex{T}}\nend\n\nddx(u::SpectralField) = # some definitions\n","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"To work with the package, objects of type X should satisfy the following requirements:","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"support the broadcasting with the dot notation for algebraic expressions including scalars and objects of the same type. For instance, notation like x .= 3.0.*y .+ 4.0.*z for three elements x, y and z of type X should be supported. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"provide methods for Base.similar(x) and Base.copy(x).","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Internally, the package makes extensive use of the dot notation, e.g. when updating cache objects during a time step. The mutability restriction prevents having, e.g., immutable StaticArrays objects as state vectors, which would probably lead to faster code on small problems. This is less important for the typical applications of this package, e.g. turbulent flow simulations where the state is generally given by multiple large three-dimensional arrays and having mutable objects is quite important for performance.","category":"page"},{"location":"quickstart/#Defining-the-dynamical-system-1","page":"Quick Start","title":"Defining the dynamical system","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Given a state x as an object of type X, the steps required to specify the dynamical system depend on whether an explicit or semi-implicit integration method is used.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"For explicit methods, a dynamical system is specified by a Julia function or some other callable object that has a method with signature","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"f(t::Real, x::X, dxdt::X) where {X}","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"This function is supposed to operate in place, should modify the content of the third argument dxdt with the time derivative at x, and additionally, time t for non-autonomous systems. Modifying the content of the second argument in the body of this function is undefined behaviour. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"example: Example\nThis example shows how to define a custom type implementing the Lorenz equations. First a custom type is defined with one field the parameter rho.struct Lorenz \n    ρ::Float64\n    Lorenz(ρ::Real = 28.0) = new(ρ)\nendThen, the type is made callable by defining the following method.function (eq::Lorenz)(t, u, dudt)\n    x, y, z = u\n    dudt[1] =  10 * (y - x)\n    dudt[2] =  eq.ρ *  x - y - x*z\n    dudt[3] = -8/3 * z + x*y\n    return dudt\nendNote how this function returns the argument that has been modified. This is not required by the package API, but can be useful in other situations.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"The semi-implicit methods that are currently implemented assume that the stiff term is linear and given by an time-invariant operator mathcalL. To define this term, the user must define a Julia type A with a method for the LinearAlgebra function mul! with signature","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"LinearAlgebra.mul!(out::X, A, x::X).","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"which computes the action of A on x and stores it in out. Modifying the content of x is undefined behaviour. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"In addition, the object A should define a method for the function Flows.ImcA, provided by this package, with signature","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Flows.ImcA(A, c::Real, y::X, z::X)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"to solves the linear system ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"    (A - c I)z = y","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"for some right hand side y of type X and a scalar c and stores the result in z, again of type X.","category":"page"},{"location":"quickstart/#Defining-the-integration-scheme-1","page":"Quick Start","title":"Defining the integration scheme","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Performing a time step typically requires temporary objects for intermediate computations, e.g. the internal stages of a Runge-Kutta method. In this package, these temporary objects are pre-allocated by creating an helper object, an instance of one of the concrete subtypes of AbstractMethod provided by the package. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"All constructors of such helper objects have the same signature and require a single argument of type X. This argument is used internally in the constructor to to pre-allocate as many similar similar objects as needed for the intermediate computations in the time step. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"example: Example\nAs an example, consider using the classical fourth-order Runge-Kutta method to integrate the Lorenz equations defined above. The state vector is implemented using a standard Julia Vector of three elements.method = RK4(zeros(3))","category":"page"},{"location":"quickstart/#Defining-the-time-stepping-method-1","page":"Quick Start","title":"Defining the time stepping method","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Once the integration scheme is defined, the user needs to specify a time stepping method. This is essentially a specification of how time steps should be selected to advance the state forward in time. This package provides different methods, but for the purpose of this quick start document, we only document one of the most used, TimeStepConstant. As the name suggested, this method indicates that the time step should be constant and equal to a value specified at construction. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"This is achieved by constructing a TimeStepConstant object as:","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"steps = TimeStepConstant(0.1)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"which signals that a constant time step Delta t = 01 will be used in the integration.","category":"page"},{"location":"quickstart/#Finally-defining-the-flow-operator-1","page":"Quick Start","title":"Finally defining the flow operator","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"With state, dynamical system, integration method and time stepping defined, we are finally ready to define the flow operator. This is achieved by using the flow function, which constructs a Flow object. It has two methods, with signature","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"flow(f::Any, method::AbstractMethod, stepping::AbstractTimeStepping)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"and ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"flow(f::Any, L::Any, method::AbstractMethod, stepping::AbstractTimeStepping)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"for problems that are integrated using explicit or semi-implicit methods, respectively.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"A Flow object is callable with the signature ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"(::Flow)(x::X, span::Tuple{Real, Real})","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"and propagates the state object x from time span[1] to a later time span[2], returning its first argument. The key observation is that for performance reasons the flow operator operates in place and overwrites its first argument. ","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"example: Example\nThis example demonstrates how to construct a Flow object approximating the flow of the Lorenz equations (defined above) using a classical fourth-order Runge-Kutta scheme with constant time step Delta t = 01.The Flow object is constructed byF = flow(Lorenz(28), RK4(zeros(3)), TimeStepConstant(1e-2))A point on the attractor can be then obtained by propagating a random initial conditions by some amount of time ```julia x = F(rand(3), (0, 100))","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Adaptive-time-stepping-1","page":"Examples","title":"Adaptive time stepping","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"TODO","category":"page"},{"location":"examples/#Adjoint-sensitivity-1","page":"Examples","title":"Adjoint sensitivity","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"TODO","category":"page"},{"location":"examples/#Integrating-variational-equations-1","page":"Examples","title":"Integrating variational equations","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"TODO","category":"page"},{"location":"monitors/#Monitor-objects-1","page":"Monitors","title":"Monitor objects","text":"","category":"section"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"A Flow operator simply maps a state vector forward in time by some specified amount. It operates in place, and does not store or record anything during the trajectory. However, it is sometimes useful to record some quantity, for instance one of the degrees of freedom, or maybe some integral quantity along a trajectory. This can be achieved by using a Monitor object.","category":"page"},{"location":"monitors/#Basic-usage-1","page":"Monitors","title":"Basic usage","text":"","category":"section"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"The constructor of the Monitor type has the signature","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"Monitor(x::X, g::Union{Callable, Function})","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"The first argument is an object of some user defined type, say X, the same type used to represent the system's state. The second argument is a function or callable object that we use to 'observe' the state along the simulation. It must accept a single argument of type X, must have the signature","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"g(::X)","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"and can return anything. ","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"example: Example\nThis example demonstrates how to define an object to monitor the first state of a dynamical system with three degrees of freedom.mon = Monitor(zeros(3), x->x[1])Note how the second argument is simply an anonymous function that extracts the first element. A more elegant approach is alsomon = Monitor(zeros(3), first)","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"In practice, in the constructor, the function is called on the first argument, the type of the output is analysed and storage to hold more elements of the same type is allocated.","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"To monitor an observable during a trajectory, the monitor object can be passed as a third argument to a Flow object. During the integration, a sample of the observable is taken t the end of every time step, including one sample at the beginning of the trajectory.","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"example: Example\nFor instance, assume F is a Flow object for the Lorenz equations and we want to monitor the norm of the state vector over a short trajectory from t=0 to t=1. This can be achieved bymon = Monitor(zeros(3), norm)\nF(x, (0, 1), mon)","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"At the end of the integration, the content of the Monitor object mon can be accessed by two helper functions. The first","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"samples(mon)","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"returns a Julia Vector with samples of the observed function, while ","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"times(mon)","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"returns a Vector containing the times whan the samples are taken. This is quite useful for plotting the some observable of system as a function of time.","category":"page"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"note: Note\nThe observable function can really return anything. For instance, if we want to observe the state, we can define a monitor with the copy function.mon = Monitor(zeros(3), copy)\nF(x, (0, 1), mon)\n# samples(mon) now contains the state at the end of every time stepIf we want to monitor more quantities, we can pass a function that returns a Tuple, like somon = Monitor(zeros(3), x->(x[1], x[2]^2))\nF(x, (0, 1), mon)so that samples(mon) returns a vector of Tuples.","category":"page"},{"location":"monitors/#Advanced-usage-1","page":"Monitors","title":"Advanced usage","text":"","category":"section"},{"location":"monitors/#","page":"Monitors","title":"Monitors","text":"The behaviour of Monitor object can be customised more finely. Consult the API page for more details.","category":"page"},{"location":"advanced/#Advanced-features-1","page":"Advanced features","title":"Advanced features","text":"","category":"section"},{"location":"advanced/#Call-dependencies-1","page":"Advanced features","title":"Call dependencies","text":"","category":"section"},{"location":"advanced/#-1","page":"Advanced features","title":"","text":"","category":"section"},{"location":"#Flows.jl-1","page":"Home","title":"Flows.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package offers a flow-like API to solve differential equations. The reason this package exists is that many numerical algorithms in dynamical systems theory require the action of a flow operator associated to a dynamical system, rather than a solve-an-initial-value-problem-and-store-its-solution approach that is available from other packages.","category":"page"},{"location":"quadrature/#Calculating-integrals-1","page":"Quadrature equations","title":"Calculating integrals","text":"","category":"section"},{"location":"quadrature/#Fundamentals-1","page":"Quadrature equations","title":"Fundamentals","text":"","category":"section"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"It is sometimes necessary to calculate the integral of some function g  mathcalX rightarrow mathbbR along a trajectory of the system, i.e. the integral","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"I = int_0^T g(mathbfx(t))mathrmdt","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"where mathbfx(t)inmathcalX is the system's state.","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"This can be achieved by adding a pure quadrature equation, i.e. augmenting the dynamical system with a further equations that gets integrated in time jointly with the main problem. In other words, the coupled system","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"left\nbeginarrayc\n  dotmathbfx(t) = mathbff(t mathbfx(t))\n  dotI(t) = g(mathbfx(t))\nendarray\nright","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"is integrated from 0 to T with initial condition I(0) = 0. It is easy to see that the final condition I(T)  is the numerical approximation of the integral above. ","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"The usefulness of this approach is that the integral is obtained without doing much, at the end of the solution. In addition, the order of accuracy of the integration methods used to advance the coupled state is the order of accuracy of the estimation of the integral above.","category":"page"},{"location":"quadrature/#Example-1","page":"Quadrature equations","title":"Example","text":"","category":"section"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"As an example let us compute the integral of the function ","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"g(mathbfx) = x_1^2","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"for a system with three degrees of freedom arranged in a standard Julia Vector. First we define the quadrature equation ","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"g(t, x, dxdt, I, dIdt) = (dIdt[1] = x[1]^2; return dIdt)","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"Note the structure of the signature.","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"We then define some initial conditions, making sure I[1] is initially set to  zero.","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"x = Float64[1.0, 3.0, 4.0]\nI = Float64[0.0]","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"Note that because the augmented state must be mutable, the extra quadrature variable must be stored in a mutable container, a Vector. In fact, one can calculate the integral of as many functions as desired, just define the function g above to fill as many components of dIdt as required.","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"We then define a flow operator, by coupling the right hand side of the differential equation (assume it is defined by a julia function f) and the additional quadrature equation","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"F = flow(couple(f, g), RK4(couple(x, I)), TimeStepConstant(0.1))","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"Note how the state and the quadrature variables are coupled toghether and passed to the RK4 constructor. This makes sure that the temporary objects in the Runge-Kutta scheme are consistent with the extra degree of freedom.","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"The flow operator can be now called with","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"F(couple(x, I), (0, 10))","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"where x is advanced forward in time from t=0 to t=10. Upon return I[1] contains an approximation of the integral","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"int_0^10 x_1^2(t)mathrmdt","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"example: Example\nIt is possible to monitor the value of the quadrature variable along a simulation. For instance, let us calculate the cumulative average of the function g(mathbfx(t)), the quantitybarg(tau) = frac1tau int_0^tau g(mathbfx(t))mathrmdtTo do so, simply define a Monitor object that observes the quadrature componentmon = Monitor(couple(x, I), xq->xq[2])After numerical integration, samples of the function barg can be obtained asg_bar = samples(mon)./times(mon)where the first element is undefined.","category":"page"},{"location":"quadrature/#","page":"Quadrature equations","title":"Quadrature equations","text":"note: Note\nThe quadrature equation can typically be integrated explicitly, even if a semi-implicit scheme is required for the main dynamics. In this case, one can couple the stiff linear part, say f_im, with the nothing value, asF = flow(couple(f_ex, g), couple(f_im, nothing), CNRK2(couple(x, I)), TimeStepConstant(0.1))This signals that the quadrature g is advanced in time using on the explicit component of the semi-implicit scheme.","category":"page"}]
}
